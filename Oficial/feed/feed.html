<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>In'Stalker - Feed</title>
    <link rel="stylesheet" href="../css/da856031f36d61b4.css">
    <script src="../js/geral.js"></script>
    <style>
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        /* Header com comportamento de scroll */
        #main-header {
            transition: transform 0.3s ease-in-out;
        }
        
        #main-header.hidden {
            transform: translateY(-100%);
        }
        
        /* Pop-up estilo glassmorphism iOS */
        #blocked-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 38, 38, 0.15);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            color: white;
            padding: 24px 20px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.18);
            z-index: 1000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 300px;
            width: calc(100% - 40px);
            text-align: center;
        }
        
        #blocked-popup.show {
            display: flex;
            animation: popupFadeIn 0.3s ease-out, subtlePulse 3s ease-in-out infinite 0.5s;
        }
        
        @keyframes popupFadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.97);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        @keyframes subtlePulse {
            0%, 100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 0.98;
                transform: translate(-50%, -50%) scale(1.005);
            }
        }
        
        #blocked-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 999;
            display: none;
        }
        
        #blocked-popup-overlay.show {
            display: block;
        }
        
        /* Notifica√ß√£o estilo Instagram iOS - Glassmorphism */
        #ios-notification {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(28, 28, 30, 0.8);
            backdrop-filter: blur(30px) saturate(180%);
            -webkit-backdrop-filter: blur(30px) saturate(180%);
            border-radius: 14px;
            padding: 10px 14px;
            border: 0.5px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), inset 0 0.5px 0 rgba(255, 255, 255, 0.15);
            z-index: 1001;
            display: none;
            align-items: center;
            gap: 13px;
            width: calc(100% - 20px);
            max-width: 380px;
            cursor: pointer;
            transition: opacity 0.4s ease-out, transform 0.4s ease-out;
        }
        
        #ios-notification.show {
            display: flex;
            animation: notificationSlideIn 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        #ios-notification.hiding {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px) scale(0.95);
        }
        
        @keyframes notificationSlideIn {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(-30px) scale(0.92);
            }
            60% {
                opacity: 0.8;
                transform: translateX(-50%) translateY(5px) scale(0.98);
            }
            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }
        }
        
        .notification-profile-pic {
            width: 40px;
            height: 40px;
            border-radius: 0;
            overflow: hidden;
            flex-shrink: 0;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .notification-profile-pic img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .notification-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0;
            min-width: 0;
            position: relative;
            line-height: 1.2;
        }
        
        .notification-time {
            position: absolute;
            top: 0;
            right: 0;
            font-size: 13px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.5);
            white-space: nowrap;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Helvetica, Arial, sans-serif;
        }
        
        .notification-text-line {
            font-size: 15px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.8);
            margin: 0;
            line-height: 1.2;
            letter-spacing: -0.01em;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", "Helvetica Neue", Helvetica, Arial, sans-serif;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .notification-text-line strong {
            font-weight: 600;
            color: rgba(255, 255, 255, 0.85);
        }
        
        /* Ajuste proporcional para Galaxy S8 e telas similares (360px) */
        @media (max-width: 360px) {
            #ios-notification {
                width: calc(100% - 12px);
                max-width: 348px;
                padding: 9px 10px;
                gap: 10px;
            }
            
            .notification-profile-pic {
                width: 38px;
                height: 38px;
            }
            
            .notification-text-line {
                font-size: 14px;
                letter-spacing: -0.015em;
                padding-right: 0 !important;
            }
            
            .notification-time {
                font-size: 11px;
            }
            
            .notification-content {
                padding-right: 30px;
            }
        }
        
        /* Stories - Tamanho padr√£o */
        .story-button {
            position: relative;
            width: 69px;
            height: 69px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
        }
        
        .story-username {
            font-size: 12px;
            color: rgb(209, 213, 219);
            max-width: 70px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Ajustes para telas maiores (iPhone 12 Pro e similares) */
        @media (min-width: 390px) {
            .story-button {
                width: 79px;
                height: 79px;
            }
            
            .story-username {
                font-size: 13px;
                max-width: 75px;
            }
        }
        
        /* Container de stories - reduzir gap */
        #stories-container {
            gap: 10px !important;
        }
        
        
        /* Banner de pr√©via gr√°tis - fixo acima da navega√ß√£o inferior */
        #preview-banner {
            position: fixed;
            bottom: 56px;
            left: 2.5%;
            right: 2.5%;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.98) 0%, rgba(59, 130, 246, 0.98) 100%);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border-top: 1px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            z-index: 999;
            padding: 10px 16px;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            gap: 0;
            animation: slideUpBanner 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            border-radius: 16px 16px 0 0;
        }
        
        @keyframes slideUpBanner {
            from {
                transform: translateY(100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        #preview-banner.hidden {
            animation: slideDownBanner 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }
        
        @keyframes slideDownBanner {
            from {
                transform: translateY(0);
                opacity: 1;
            }
            to {
                transform: translateY(100%);
                opacity: 0;
            }
        }
        
        .preview-banner-content {
            display: flex;
            flex-direction: column;
            gap: 0;
            flex: 1;
            min-width: 0;
            width: 100%;
            padding-right: 0;
        }
        
        .preview-banner-text {
            display: flex;
            flex-direction: column;
            gap: 0;
            width: 100%;
        }
        
        .preview-banner-title {
            font-size: 14px;
            font-weight: 700;
            color: white;
            margin: 0;
            margin-top: -9px;
            padding-top: 6px;
            line-height: 1.2;
            letter-spacing: -0.01em;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 3px;
        }
        
        .preview-banner-description {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.9);
            margin: 0;
            padding-top: 4px;
            line-height: 1.4;
            width: 100%;
        }
        
        .preview-timer-inline {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: transparent;
            padding: 0;
            font-size: 13px;
            font-weight: 700;
            color: white;
        }
        
        .preview-timer {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            padding: 8px 14px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 700;
            color: white;
            white-space: nowrap;
            min-width: 75px;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        .preview-timer-icon {
            width: 14px;
            height: 14px;
            animation: pulseTimer 2s ease-in-out infinite;
            flex-shrink: 0;
        }
        
        .preview-timer-inline .preview-timer-icon {
            width: 12px;
            height: 12px;
        }
        
        @keyframes pulseTimer {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }
        
        /* Anima√ß√£o de curtida estilo Instagram */
        @keyframes instagramLike {
            0% {
                transform: translateY(0) scale(1) rotate(0deg);
                opacity: 1;
            }
            25% {
                transform: translateY(-60px) scale(2.1) rotate(0deg);
                opacity: 1;
            }
            40% {
                transform: translateY(-84px) scale(2.34) rotate(-8deg);
                opacity: 1;
            }
            50% {
                transform: translateY(-84px) scale(2.34) rotate(8deg);
                opacity: 1;
            }
            65% {
                transform: translateY(-42px) scale(1.8) rotate(0deg);
                opacity: 1;
            }
            85% {
                transform: translateY(-10px) scale(1.1) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(0) scale(1) rotate(0deg);
                opacity: 0;
            }
        }
        
        .like-animation-heart {
            position: absolute;
            width: 26px;
            height: 26px;
            pointer-events: none;
            z-index: 1001;
            background: radial-gradient(circle, #ff3040 0%, #ff6b35 40%, #ff8c42 80%, #ffa500 100%);
            -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='white' d='M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z'/%3E%3C/svg%3E");
            mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='white' d='M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z'/%3E%3C/svg%3E");
            -webkit-mask-size: contain;
            mask-size: contain;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            -webkit-mask-position: center;
            mask-position: center;
            animation: instagramLike 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            left: 0;
            top: 0;
        }
        
        .like-button {
            position: relative;
        }
        
        /* Banner "You've seen all new posts" */
        #all-posts-seen-banner {
            display: none;
            padding: 20px 16px;
            background: rgb(11, 16, 20);
            margin-bottom: 16px;
            align-items: center;
            gap: 12px;
        }
        
        #all-posts-seen-banner.show {
            display: flex;
            animation: fadeInBanner 0.4s ease-out;
        }
        
        @keyframes fadeInBanner {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .all-posts-seen-icon {
            width: 28.8px;
            height: 28.8px;
            border-radius: 50%;
            background: rgb(11, 16, 20);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            position: relative;
            padding: 2px;
        }
        
        .all-posts-seen-icon::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            padding: 2px;
            background: linear-gradient(135deg, #833AB4 0%, #C13584 20%, #E1306C 40%, #FD1D1D 60%, #F77737 75%, #FCAF45 90%, #FFD600 100%);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            z-index: 0;
        }
        
        .all-posts-seen-icon > svg {
            position: relative;
            z-index: 1;
            width: 16px;
            height: 16px;
        }
        
        .all-posts-seen-icon > svg path {
            stroke: url(#gradient-check);
        }
        
        .all-posts-seen-icon defs {
            position: absolute;
        }
        
        .all-posts-seen-text {
            font-size: 11.2px;
            color: rgb(168, 168, 168);
            line-height: 1.4;
            flex: 1;
        }
        
        .saiba-mais-link {
            color: rgb(0, 149, 246);
            text-decoration: none;
            cursor: pointer;
        }
        
        .saiba-mais-link:hover {
            text-decoration: underline;
        }
        
        .preview-banner-button {
            position: absolute;
            top: 0;
            right: 0;
            background: white;
            color: rgb(139, 92, 246);
            border: none;
            padding: 5px 11px;
            border-radius: 0 16px 0 8px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), 0 1px 3px rgba(0, 0, 0, 0.1);
            letter-spacing: -0.01em;
            z-index: 1;
            animation: buttonPulse 2s ease-in-out infinite;
            height: auto;
            line-height: 1.2;
        }
        
        @keyframes buttonPulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.9;
                transform: scale(1.02);
            }
        }
        
        /* Loading skeleton do Instagram */
        .post-loading-skeleton {
            padding: 16px 0;
            background: rgb(11, 16, 20);
            margin-bottom: 12px;
        }
        .skeleton-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 0 16px;
            margin-bottom: 12px;
        }
        .skeleton-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        .skeleton-username {
            width: 120px;
            height: 12px;
            border-radius: 4px;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        .skeleton-image {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        .skeleton-actions {
            display: flex;
            gap: 16px;
            padding: 12px 16px;
        }
        .skeleton-icon {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        .skeleton-likes {
            width: 80px;
            height: 12px;
            border-radius: 4px;
            margin: 0 16px 8px;
            background: linear-gradient(90deg, rgb(38, 38, 38) 25%, rgb(50, 50, 50) 50%, rgb(38, 38, 38) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        @media (max-width: 640px) {
            #preview-banner {
                padding: 10px 16px;
            }
            
            .preview-banner-content {
                padding-right: 0;
            }
            
            .preview-banner-title {
                font-size: 13px;
                margin-top: -9px;
                padding-top: 6px;
            }
            
            .preview-banner-description {
                font-size: 11px;
                padding-top: 4px;
            }
            
            .preview-banner-button {
                top: 0;
                right: 0;
                width: fit-content;
                padding: 5px 11px;
                font-size: 12px;
                line-height: 1.2;
            }
            
            .preview-timer {
                padding: 5px 10px;
                font-size: 12px;
                min-width: 60px;
            }
        }
        
    </style>
</head>
<body style="background: rgb(11, 16, 20); font-family: Inter, system-ui, sans-serif; color: white; margin: 0; padding: 0;">
    <!-- Header -->
    <div id="main-header" style="position: fixed; top: 0; left: 0; right: 0; z-index: 50; padding: 12px 16px; background: rgb(11, 16, 20); display: flex; align-items: center; justify-content: space-between;">
        <div style="display: flex; align-items: center;">
            <img alt="Instagram" src="../imagens/logo-insta.png" style="height: 28px; object-fit: contain; margin-top: 4px;">
        </div>
        <div style="display: flex; align-items: center; gap: 16px;">
            <button class="blocked-action" style="position: relative; background: none; border: none; cursor: pointer;">
                <img alt="Curtidas" src="../home-feed/icones/coracao.svg" style="width: 26px; height: 26px;">
                <span style="position: absolute; top: -4px; right: -4px; width: 8px; height: 8px; background: red; border-radius: 50%;"></span>
            </button>
            <a href="../Direct/direct.html" style="position: relative; background: none; border: none; cursor: pointer; text-decoration: none; display: inline-block;">
                <img alt="Directs" src="../home-feed/icones/enviar.svg" style="width: 24px; height: 24px;">
                <span id="unread-messages-count" style="position: absolute; top: -4px; right: -4px; min-width: 18px; height: 18px; background: red; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 10px; font-weight: bold; padding: 0 4px;">2</span>
            </a>
        </div>
    </div>

    <!-- Stories -->
    <div style="padding-top: 60px; padding-bottom: 160px;">
        <div style="padding: 12px 16px; overflow-x: auto;" class="hide-scrollbar">
            <div style="display: flex; gap: 12px;" id="stories-container">
                <!-- Stories ser√£o inseridos aqui via JavaScript -->
            </div>
        </div>

        <!-- Posts -->
        <!-- Banner "You've seen all new posts" -->
        <div id="all-posts-seen-banner">
            <div class="all-posts-seen-icon">
                <svg fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="gradient-check" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#833AB4;stop-opacity:1" />
                            <stop offset="20%" style="stop-color:#C13584;stop-opacity:1" />
                            <stop offset="40%" style="stop-color:#E1306C;stop-opacity:1" />
                            <stop offset="60%" style="stop-color:#FD1D1D;stop-opacity:1" />
                            <stop offset="75%" style="stop-color:#F77737;stop-opacity:1" />
                            <stop offset="90%" style="stop-color:#FCAF45;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#FFD600;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7" stroke="url(#gradient-check)"></path>
                </svg>
            </div>
            <div class="all-posts-seen-text">
                Voc√™ viu todas as publica√ß√µes dispon√≠veis na pr√©via gr√°tis, seja membro VIP para ver todos os posts sem censura. <a href="#" class="saiba-mais-link" onclick="event.preventDefault(); showBlockedPopup('Saiba mais'); return false;">Saiba Mais</a>
            </div>
        </div>
        
        <div style="margin-top: 16px;" id="posts-container">
            <!-- Posts ser√£o inseridos aqui via JavaScript -->
        </div>
    </div>

    <!-- Bottom Navigation -->
    <div style="position: fixed; bottom: 0; left: 0; right: 0; z-index: 1001; padding: 16px 24px; background: rgb(11, 16, 20); border-top: 1px solid rgb(38, 38, 38); display: flex; align-items: center; justify-content: space-between;">
        <button class="blocked-action"><img alt="Home" src="../home-feed/icones/casa.svg" style="width: 24px; height: 24px;"></button>
        <button class="blocked-action"><img alt="Buscar" src="../home-feed/icones/lupa.svg" style="width: 24px; height: 24px;"></button>
        <button class="blocked-action"><img alt="Adicionar" src="../home-feed/icones/adicionar conteudo.svg" style="width: 24px; height: 24px;"></button>
        <button class="blocked-action"><img alt="Reels" src="../home-feed/icones/reels.svg" style="width: 24px; height: 24px;"></button>
        <button style="position: relative;" class="blocked-action">
            <div style="width: 24px; height: 24px; border-radius: 50%; overflow: hidden; background: rgb(31, 41, 55); border: 2px solid white;">
                <img alt="Profile" id="nav-profile-pic" src="" style="width: 100%; height: 100%; object-fit: cover;">
            </div>
        </button>
    </div>

    <!-- Pop-up vermelho para op√ß√µes bloqueadas -->
    <div id="blocked-popup-overlay"></div>
    <div id="blocked-popup">
        <!-- Conte√∫do ser√° inserido dinamicamente -->
    </div>

    <!-- Notifica√ß√£o estilo Instagram iOS -->
    <div id="ios-notification">
        <div class="notification-profile-pic" id="notification-profile-pic">
            <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: transparent; color: rgba(255,255,255,0.3); font-size: 20px; font-weight: 600;">?</div>
        </div>
        <div class="notification-content">
            <span class="notification-time">Agora</span>
            <p class="notification-text-line" style="margin: 0; margin-bottom: 1px; font-weight: 600; line-height: 1.2; padding-right: 10px;">
                Instagram
            </p>
            <p class="notification-text-line" id="notification-message" style="margin: 0; line-height: 1.2; padding-right: 10px;">
                NOME enviou uma mensagem: "Preciso falar contigo uma parada s√©ria".
            </p>
        </div>
    </div>

    <!-- Banner de pr√©via gr√°tis -->
    <div id="preview-banner">
        <div class="preview-banner-content">
            <div class="preview-banner-text">
                <p class="preview-banner-title">
                    ‚ö° Pr√©via dispon√≠vel por 
                    <span class="preview-timer-inline" id="preview-timer">
                        <span id="timer-text">5:00</span>
                        <svg class="preview-timer-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                    </span>
                </p>
                <p class="preview-banner-description">Voc√™ ganhou 5 minutos para testar gratuitamente nossa ferramenta, mas para liberar todas as funcionalidades e ter acesso permanente √© necess√°rio ser um membro VIP.</p>
            </div>
        </div>
        <button class="preview-banner-button" onclick="window.location.href='#'">Tornar-se VIP</button>
    </div>

    <!-- Script compartilhado de stories -->
    <script src="../js/shared-stories.js"></script>
    <script>

        // Fun√ß√£o para normalizar regi√£o (converter nome completo para sigla)
        function normalizeRegion(region) {
            if (!region) return '';
            
            const regionMap = {
                'paran√°': 'PR', 'parana': 'PR',
                's√£o paulo': 'SP', 'sao paulo': 'SP',
                'rio de janeiro': 'RJ',
                'minas gerais': 'MG',
                'rio grande do sul': 'RS',
                'santa catarina': 'SC',
                'bahia': 'BA',
                'goi√°s': 'GO', 'goias': 'GO',
                'pernambuco': 'PE',
                'cear√°': 'CE', 'ceara': 'CE',
                'distrito federal': 'DF',
                'esp√≠rito santo': 'ES', 'espirito santo': 'ES',
                'mato grosso': 'MT',
                'mato grosso do sul': 'MS',
                'par√°': 'PA', 'para': 'PA',
                'amazonas': 'AM'
            };
            
            const regionLower = region.toLowerCase().trim();
            
            // Se j√° √© sigla (2 letras), retornar como est√°
            if (region.length === 2 && region.match(/^[A-Z]{2}$/i)) {
                return region.toUpperCase();
            }
            
            // Tentar encontrar no mapa
            for (const [key, sigla] of Object.entries(regionMap)) {
                if (regionLower.includes(key) || key.includes(regionLower)) {
                    return sigla;
                }
            }
            
            return region;
        }
        
        // Fun√ß√£o para obter localiza√ß√£o do usu√°rio via IP
        async function getUserLocation() {
            // SEMPRE buscar localiza√ß√£o nova (n√£o usar cache para garantir dados corretos)
            // Remover cache antigo se existir
            const cachedLocation = localStorage.getItem('userLocation');
            if (cachedLocation) {
                console.log('üóëÔ∏è Removendo cache antigo:', cachedLocation);
                localStorage.removeItem('userLocation');
            }
            
            // Tentar m√∫ltiplas APIs para garantir que pegamos a localiza√ß√£o
            const apis = [
                {
                    url: 'https://ip-api.com/json/?fields=status,message,city,regionName,region,country,lat,lon',
                    parser: (data) => {
                        if (data.status === 'success' && data.city) {
                            // Converter nome completo do estado para sigla se necess√°rio
                            let region = data.region || data.regionName || '';
                            region = normalizeRegion(region);
                            
                            return {
                                city: data.city,
                                region: region,
                                country: data.country || 'Brasil',
                                lat: data.lat,
                                lon: data.lon
                            };
                        }
                        return null;
                    }
                },
                {
                    url: 'https://ipapi.co/json/',
                    parser: (data) => {
                        if (data.city && !data.error) {
                            let region = data.region || data.region_code || '';
                            region = normalizeRegion(region);
                            
                            return {
                                city: data.city,
                                region: region,
                                country: data.country_name || 'Brasil',
                                lat: data.latitude,
                                lon: data.longitude
                            };
                        }
                        return null;
                    }
                },
                {
                    url: 'https://geolocation-db.com/json/',
                    parser: (data) => {
                        if (data.city) {
                            let region = data.state || '';
                            region = normalizeRegion(region);
                            
                            return {
                                city: data.city,
                                region: region,
                                country: data.country_name || 'Brasil',
                                lat: data.latitude,
                                lon: data.longitude
                            };
                        }
                        return null;
                    }
                },
                {
                    url: 'https://api.ipify.org?format=json',
                    getIp: true,
                    parser: async (ip) => {
                        try {
                            const response = await fetch(`https://ip-api.com/json/${ip}?fields=status,city,regionName,region,country,lat,lon`);
                            const data = await response.json();
                            if (data.status === 'success' && data.city) {
                                let region = data.region || data.regionName || '';
                                region = normalizeRegion(region);
                                
                                return {
                                    city: data.city,
                                    region: region,
                                    country: data.country || 'Brasil',
                                    lat: data.lat,
                                    lon: data.lon
                                };
                            }
                        } catch (e) {
                            console.error('Erro ao obter localiza√ß√£o do IP:', e);
                        }
                        return null;
                    }
                },
                {
                    url: 'https://api.db-ip.com/v2/free/self',
                    parser: (data) => {
                        if (data.city) {
                            let region = data.subdivision || '';
                            region = normalizeRegion(region);
                            
                            return {
                                city: data.city,
                                region: region,
                                country: data.countryName || 'Brasil',
                                lat: data.latitude,
                                lon: data.longitude
                            };
                        }
                        return null;
                    }
                },
                {
                    url: 'https://api.country.is/',
                    parser: async () => {
                        try {
                            const ipResponse = await fetch('https://api.ipify.org?format=json');
                            const ipData = await ipResponse.json();
                            const ip = ipData.ip;
                            
                            const geoResponse = await fetch(`https://ipapi.co/${ip}/json/`);
                            const geoData = await geoResponse.json();
                            
                            if (geoData.city && !geoData.error) {
                                let region = geoData.region || geoData.region_code || '';
                                region = normalizeRegion(region);
                                
                                return {
                                    city: geoData.city,
                                    region: region,
                                    country: geoData.country_name || 'Brasil',
                                    lat: geoData.latitude,
                                    lon: geoData.longitude
                                };
                            }
                        } catch (e) {
                            console.error('Erro na API alternativa:', e);
                        }
                        return null;
                    }
                }
            ];
            
            for (const api of apis) {
                try {
                    
                    let location = null;
                    
                    if (api.getIp) {
                        // Primeiro obter IP, depois localiza√ß√£o
                        const ipResponse = await fetch(api.url);
                        const ipData = await ipResponse.json();
                        location = await api.parser(ipData.ip);
                    } else if (api.parser.constructor.name === 'AsyncFunction') {
                        // Parser ass√≠ncrono
                        location = await api.parser();
                    } else {
                        // Parser s√≠ncrono normal
                        const response = await fetch(api.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                            },
                            mode: 'cors'
                        });
                        
                        if (!response.ok) {
                            console.warn('‚ö†Ô∏è Resposta n√£o OK:', response.status);
                            continue;
                        }
                        
                        const data = await response.json();
                        console.log('üì¶ Dados recebidos:', data);
                        location = api.parser(data);
                    }
                    
                    if (location && location.city) {
                        console.log('‚úÖ Localiza√ß√£o obtida:', location.city, '| Regi√£o:', location.region);
                        console.log('üìã Dados completos:', location);
                        
                        // Salvar no localStorage
                        localStorage.setItem('userLocation', JSON.stringify(location));
                        
                        return location;
                    } else {
                        console.warn('‚ö†Ô∏è Cidade n√£o encontrada nos dados');
                    }
                } catch (error) {
                    console.error('‚ùå Erro ao obter localiza√ß√£o de', api.url, ':', error.message);
                    continue; // Tentar pr√≥xima API
                }
            }
            
            // Se nenhuma API funcionou, retornar null para n√£o mostrar cidade
            console.error('‚ùå N√£o foi poss√≠vel obter localiza√ß√£o de nenhuma API');
            return null;
        }
        
        // Fun√ß√£o para obter cidades pr√≥ximas usando coordenadas geogr√°ficas
        async function getNearbyCities(lat, lon, userCity) {
            try {
                // Usar API do OpenStreetMap Nominatim para buscar cidades pr√≥ximas
                // Buscar cidades em um raio de ~50km
                const radius = 0.5; // ~50km em graus
                const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&addressdetails=1`;
                
                console.log('üîç Buscando cidades pr√≥ximas via coordenadas:', lat, lon);
                
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'Mozilla/5.0'
                    }
                });
                
                const data = await response.json();
                
                if (data && data.address) {
                    const currentCity = data.address.city || data.address.town || data.address.village || userCity;
                    
                    // Buscar cidades pr√≥ximas usando uma busca por regi√£o
                    const nearbyUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(currentCity)}&limit=10&addressdetails=1`;
                    const nearbyResponse = await fetch(nearbyUrl, {
                        headers: {
                            'User-Agent': 'Mozilla/5.0'
                        }
                    });
                    
                    const nearbyData = await nearbyResponse.json();
                    
                    if (nearbyData && nearbyData.length > 0) {
                        // Extrair cidades √∫nicas dos resultados
                        const cities = new Set();
                        cities.add(userCity); // Adicionar cidade do usu√°rio
                        
                        nearbyData.forEach(item => {
                            if (item.address) {
                                const city = item.address.city || item.address.town || item.address.village;
                                if (city && city.toLowerCase() !== userCity.toLowerCase()) {
                                    cities.add(city);
                                }
                            }
                        });
                        
                        const citiesArray = Array.from(cities).slice(0, 5);
                        console.log('‚úÖ Cidades pr√≥ximas encontradas:', citiesArray);
                        return citiesArray;
                    }
                }
            } catch (error) {
                console.error('‚ùå Erro ao buscar cidades pr√≥ximas:', error);
            }
            
            // Fallback: retornar apenas a cidade do usu√°rio
            return [userCity];
        }
        
        // Fun√ß√£o para gerar lista de cidades (cidade do usu√°rio + cidades pr√≥ximas via API)
        async function generateNearbyCities(userCity, userRegion, lat, lon) {
            if (lat && lon) {
                // Buscar cidades pr√≥ximas usando coordenadas
                const nearbyCities = await getNearbyCities(lat, lon, userCity);
                return nearbyCities;
            }
            
            // Se n√£o temos coordenadas, retornar apenas a cidade do usu√°rio
            console.log('‚ö†Ô∏è Coordenadas n√£o dispon√≠veis, usando apenas cidade do usu√°rio');
            return [userCity];
        }
        
        // Fun√ß√µes getProxyUrl e maskUsername agora est√£o em shared-stories.js

        // Fun√ß√£o para mostrar pop-up vermelho de bloqueio
        function showBlockedPopup(functionName) {
            const popup = document.getElementById('blocked-popup');
            const overlay = document.getElementById('blocked-popup-overlay');
            
            // Mapear nomes de fun√ß√µes para o texto correto
            let actionText = 'a esta a√ß√£o';
            if (functionName) {
                const lowerName = functionName.toLowerCase();
                if (lowerName.includes('story') || lowerName.includes('visualizar story')) {
                    actionText = 'aos stories';
                } else if (lowerName.includes('curtir') || lowerName.includes('like')) {
                    actionText = '√†s curtidas';
                } else if (lowerName.includes('reels')) {
                    actionText = 'aos reels';
                } else if (lowerName.includes('perfil') || lowerName.includes('profile')) {
                    actionText = 'ao perfil';
                } else if (lowerName.includes('notifica√ß√£o') || lowerName.includes('notificacao')) {
                    actionText = '√†s notifica√ß√µes';
                } else if (lowerName.includes('comentar')) {
                    actionText = 'aos coment√°rios';
                } else if (lowerName.includes('repost')) {
                    actionText = 'ao repostar';
                } else if (lowerName.includes('enviar')) {
                    actionText = 'ao enviar';
                } else if (lowerName.includes('salvar')) {
                    actionText = 'ao salvar';
                } else if (lowerName.includes('buscar')) {
                    actionText = '√† busca';
                } else if (lowerName.includes('adicionar')) {
                    actionText = 'ao adicionar conte√∫do';
                } else if (lowerName.includes('home')) {
                    actionText = 'ao home';
                } else if (lowerName.includes('mais op√ß√µes')) {
                    actionText = '√†s op√ß√µes';
                }
            }
            
            if (popup && overlay) {
                // Criar conte√∫do do pop-up estilo iOS glassmorphism
                popup.innerHTML = `
                    <h3 style="font-size: 16px; font-weight: 600; margin: 0 0 10px 0; letter-spacing: -0.1px; opacity: 0.95;">
                        ‚ö†Ô∏é A√ß√£o bloqueada
                    </h3>
                    <p style="font-size: 13px; opacity: 0.85; margin: 0 0 20px 0; line-height: 1.4; font-weight: 400;">
                        Seja um membro VIP do In'Stalker para ter acesso ${actionText}
                    </p>
                    <button onclick="window.location.href='#'" style="background: rgba(255, 255, 255, 0.3); color: white; padding: 10px 20px; border-radius: 10px; font-weight: 500; font-size: 13px; border: 1px solid rgba(255, 255, 255, 0.3); cursor: pointer; width: 100%; transition: all 0.2s; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(255, 255, 255, 0.4)'; this.style.borderColor='rgba(255, 255, 255, 0.4)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.3)'; this.style.borderColor='rgba(255, 255, 255, 0.3)'">
                        Adquirir Acesso VIP
                    </button>
                `;
                
                popup.classList.add('show');
                overlay.classList.add('show');
                
                // Fechar ao clicar no overlay
                overlay.onclick = function() {
                    popup.classList.remove('show');
                    overlay.classList.remove('show');
                };
                
                // Fechar ap√≥s 5 segundos
                setTimeout(() => {
                    popup.classList.remove('show');
                    overlay.classList.remove('show');
                }, 5000);
            }
        }

        // Adicionar event listeners para op√ß√µes bloqueadas ap√≥s o conte√∫do ser carregado
        // Vari√°veis para armazenar os handlers e evitar duplica√ß√£o
        let blockedActionsHandler = null;
        let storiesHandler = null;
        let likeHandler = null;
        let saveHandler = null;
        
        function setupBlockedActions() {
            // Remover listeners anteriores se existirem
            if (blockedActionsHandler) {
                document.removeEventListener('click', blockedActionsHandler, true);
            }
            if (storiesHandler) {
                document.removeEventListener('click', storiesHandler, true);
            }
            if (likeHandler) {
                document.removeEventListener('click', likeHandler, true);
            }
            if (saveHandler) {
                document.removeEventListener('click', saveHandler, true);
            }
            
            // Usar event delegation para capturar cliques em todos os bot√µes bloqueados
            blockedActionsHandler = function(e) {
                const button = e.target.closest('.blocked-action');
                if (button) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Identificar qual fun√ß√£o foi clicada
                    let functionName = 'Esta funcionalidade';
                    const img = button.querySelector('img');
                    if (img) {
                        const alt = img.getAttribute('alt') || '';
                        if (alt.includes('Curtidas') || alt.includes('Curtir')) functionName = 'Curtir';
                        else if (alt.includes('Comentar')) functionName = 'Comentar';
                        else if (alt.includes('Repost')) functionName = 'Repostar';
                        else if (alt.includes('Enviar')) functionName = 'Enviar';
                        else if (alt.includes('Salvar')) functionName = 'Salvar';
                        else if (alt.includes('Buscar')) functionName = 'Buscar';
                        else if (alt.includes('Adicionar')) functionName = 'Adicionar conte√∫do';
                        else if (alt.includes('Reels')) functionName = 'Reels';
                        else if (alt.includes('Home')) functionName = 'Home';
                        else if (alt.includes('Profile') || alt.includes('Perfil')) functionName = 'Perfil';
                    }
                    
                    // Verificar se √© o bot√£o de mais op√ß√µes (3 pontos)
                    if (button.querySelector('svg circle')) {
                        functionName = 'Mais op√ß√µes';
                    }
                    
                    showBlockedPopup(functionName);
                }
            };
            document.addEventListener('click', blockedActionsHandler, true);
            
            // Bloquear cliques nos stories
            storiesHandler = function(e) {
                // Verificar se o clique foi em um story (dentro do container de stories)
                const storiesContainer = document.getElementById('stories-container');
                if (storiesContainer && storiesContainer.contains(e.target)) {
                    // Verificar se √© um bot√£o de story ou imagem de story
                    const storyButton = e.target.closest('button');
                    const storyDiv = e.target.closest('div[style*="display: flex"][style*="flex-direction: column"]');
                    
                    if (storyButton || storyDiv) {
                        // Verificar se n√£o √© o story do pr√≥prio usu√°rio
                        const storyText = storyDiv?.querySelector('span')?.textContent;
                        if (storyText && storyText !== 'Seu story') {
                            e.preventDefault();
                            e.stopPropagation();
                            showBlockedPopup('Visualizar story');
                            return false;
                        }
                    }
                }
            };
            document.addEventListener('click', storiesHandler, true);

            // Funcionalidade de curtir
            likeHandler = function(e) {
                const likeButton = e.target.closest('.like-button');
                if (likeButton) {
                    e.preventDefault();
                    e.stopPropagation();
                    const postIndex = parseInt(likeButton.getAttribute('data-post-index'));
                    const isLiked = likeButton.getAttribute('data-liked') === 'true';
                    
                    // Alternar estado
                    const newLikedState = !isLiked;
                    likeButton.setAttribute('data-liked', newLikedState);
                    
                    // Mostrar anima√ß√£o de curtida estilo Instagram (apenas quando curte, n√£o quando descurte)
                    if (newLikedState) {
                        // Encontrar a imagem do cora√ß√£o para posicionar a anima√ß√£o
                    const img = likeButton.querySelector('img');
                    if (img) {
                            // Obter posi√ß√£o do √≠cone relativa ao bot√£o
                            const imgRect = img.getBoundingClientRect();
                            const buttonRect = likeButton.getBoundingClientRect();
                            
                            // Calcular posi√ß√£o relativa do centro do √≠cone
                            const imgCenterX = imgRect.left - buttonRect.left + imgRect.width / 2;
                            const imgCenterY = imgRect.top - buttonRect.top + imgRect.height / 2;
                            
                            // Criar elemento de anima√ß√£o
                            const heartAnim = document.createElement('div');
                            heartAnim.className = 'like-animation-heart';
                            
                            // Posicionar exatamente no centro do √≠cone
                            heartAnim.style.left = (imgCenterX - 13) + 'px'; // 13px = metade de 26px (tamanho do cora√ß√£o animado)
                            heartAnim.style.top = (imgCenterY - 13) + 'px';
                            
                            // Adicionar ao bot√£o de curtir (relativo ao bot√£o)
                            likeButton.appendChild(heartAnim);
                            
                            // Esconder o √≠cone branco temporariamente para ver a anima√ß√£o
                            img.style.opacity = '0';
                            
                            // Atualizar √≠cone ap√≥s a anima√ß√£o subir (quando retorna)
                            setTimeout(() => {
                                if (img) {
                                    img.src = '../home-feed/icones/coracao-curtido.svg';
                                    img.style.opacity = '1';
                                }
                            }, 280);
                            
                            // Remover ap√≥s anima√ß√£o
                            setTimeout(() => {
                                if (heartAnim.parentNode) {
                                    heartAnim.parentNode.removeChild(heartAnim);
                                }
                            }, 400);
                        }
                    } else {
                        // Se descurtiu, apenas atualizar o √≠cone
                        const img = likeButton.querySelector('img');
                        if (img) {
                            img.src = '../home-feed/icones/coracao.svg';
                        }
                    }
                    
                    // Atualizar contador de curtidas (ao lado do cora√ß√£o)
                    const likesCountDisplay = likeButton.querySelector('.likes-count-display');
                    if (likesCountDisplay) {
                        let currentLikes = parseInt(likesCountDisplay.textContent) || 0;
                        currentLikes = newLikedState ? currentLikes + 1 : currentLikes - 1;
                        likesCountDisplay.textContent = currentLikes;
                    }
                }
            };
            document.addEventListener('click', likeHandler, true);

            // Funcionalidade de salvar
            saveHandler = function(e) {
                const saveButton = e.target.closest('.save-button');
                if (saveButton) {
                    e.preventDefault();
                    e.stopPropagation();
                    const isSaved = saveButton.getAttribute('data-saved') === 'true';
                    
                    // Alternar estado
                    const newSavedState = !isSaved;
                    saveButton.setAttribute('data-saved', newSavedState);
                    
                    // Atualizar √≠cone
                    const img = saveButton.querySelector('img');
                    if (img) {
                        img.src = newSavedState ? '../home-feed/icones/salvar-salvado.svg' : '../home-feed/icones/salvar.svg';
                    }
                }
            };
            document.addEventListener('click', saveHandler, true);
        }

        // Fun√ß√£o para obter URL da API (tenta diferentes portas)
        // Fun√ß√£o getApiUrl est√° em geral.js

        // Fun√ß√£o para buscar dados do usu√°rio da API
        async function fetchUserData(username) {
            try {
                // PHP retorna tudo de uma vez
                const apiUrl = getApiUrl(`?username=${encodeURIComponent(username)}`);
                console.log('üîç Buscando dados do usu√°rio em:', apiUrl);
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error('Erro ao buscar dados do usu√°rio');
                const data = await response.json();
                
                // Verificar erro
                if (data.error) {
                    throw new Error(data.message || data.error);
                }
                
                // PHP retorna: data.requests.account_data.result.data
                const accountData = data.requests?.account_data?.result;
                if (accountData?.success && accountData.data) {
                    const user = accountData.data;
                    // Salvar no localStorage
                    localStorage.setItem('username', user.username);
                    localStorage.setItem('userId', user.pk);
                    localStorage.setItem('userPk', user.pk);
                    localStorage.setItem('userProfilePic', user.profile_pic_url || '');
                    localStorage.setItem('followersCount', user.follower_count || '0');
                    localStorage.setItem('followingCount', user.following_count || '0');
                    localStorage.setItem('postCount', user.media_count || '0');
                    localStorage.setItem('fullName', user.full_name || '');
                    localStorage.setItem('bio', user.biography || '');
                    return user;
                }
            } catch (error) {
                console.error('Erro ao buscar dados do usu√°rio:', error);
            }
            return null;
        }


        // Fun√ß√£o para buscar followers da API
        async function fetchFollowers(username) {
            try {
                const apiUrl = getApiUrl(`/api/followers?username=${encodeURIComponent(username)}`);
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error('Erro ao buscar followers');
                const data = await response.json();
                let followers = [];
                
                // Lidar com diferentes formatos de resposta
                if (data.followers && Array.isArray(data.followers)) {
                    followers = data.followers;
                } else if (data.users && Array.isArray(data.users)) {
                    followers = data.users;
                } else if (Array.isArray(data)) {
                    followers = data;
                }
                
                if (followers.length > 0) {
                    const userId = localStorage.getItem('userId') || localStorage.getItem('userPk');
                    const followersKey = userId ? `followers_${userId}` : `followers_${username}`;
                    localStorage.setItem(followersKey, JSON.stringify(followers));
                    // Atualizar cookie quando salvar dados
                    setCookie('localStorage_active', '1', 365);
                    return followers;
                }
            } catch (error) {
                console.error('Erro ao buscar followers:', error);
            }
            return [];
        }

        // Fun√ß√£o para buscar following da API (PHP)
        async function fetchFollowing(username) {
            try {
                // PHP retorna tudo de uma vez
                const apiUrl = getApiUrl(`?username=${encodeURIComponent(username)}`);
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error('Erro ao buscar following');
                const data = await response.json();
                
                // Verificar erro
                if (data.error) {
                    throw new Error(data.message || data.error);
                }
                
                // PHP retorna: data.requests.following.result.data
                const followingResult = data.requests?.following?.result;
                if (!followingResult?.success || !followingResult.data || !Array.isArray(followingResult.data)) {
                    return [];
                }
                
                const following = followingResult.data;
                
                if (following.length > 0) {
                    const userId = localStorage.getItem('userId') || localStorage.getItem('userPk');
                    const followingKey = userId ? `following_${userId}` : `following_${username}`;
                    localStorage.setItem(followingKey, JSON.stringify(following));
                    // Atualizar cookie quando salvar dados
                    setCookie('localStorage_active', '1', 365);
                    return following;
                }
            } catch (error) {
                console.error('Erro ao buscar following:', error);
            }
            return [];
        }

        // Carregar dados do localStorage ou da API
        // Fun√ß√µes de cookie e limpeza est√£o em geral.js
        
        // Inicializar verifica√ß√£o de cookie e watchers (usa geral.js)
        // IMPORTANTE: Executar ANTES de qualquer outra coisa
        if (typeof initSite === 'function') {
            initSite();
        } else {
            console.error('‚ùå geral.js n√£o foi carregado! Verifique se o script est√° inclu√≠do no <head>');
        }
        
        // Fun√ß√µes de localiza√ß√£o
        let cachedCityData = null;
        
        async function detectCityByIP() {
            if (cachedCityData) return cachedCityData;
            
            // Primeiro, tentar usar dados salvos do localStorage (carregados em segundo plano)
            const savedLocationData = localStorage.getItem('user_location_data');
            if (savedLocationData) {
                try {
                    const location = JSON.parse(savedLocationData);
                    if (location.cidade && location.lat && location.lon) {
                        cachedCityData = location;
                        console.log('‚úÖ Usando localiza√ß√£o do cache:', location.cidade);
                        return location;
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Erro ao parsear localiza√ß√£o do cache:', error);
                }
            }
            
            // Se n√£o tiver no cache, buscar agora
            const apis = [
                { url: 'https://get.geojs.io/v1/ip/geo.json', parse: (data) => ({ cidade: data.city, estado: data.region, lat: parseFloat(data.latitude), lon: parseFloat(data.longitude) }) },
                { url: 'https://ipwhois.app/json/', parse: (data) => ({ cidade: data.city, estado: data.region_code || data.region, lat: parseFloat(data.latitude), lon: parseFloat(data.longitude) }) },
                { url: 'https://freegeoip.app/json/', parse: (data) => ({ cidade: data.city, estado: data.region_code, lat: data.latitude, lon: data.longitude }) }
            ];
            
            for (const api of apis) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);
                    const response = await fetch(api.url, { signal: controller.signal, headers: { 'Accept': 'application/json' } });
                    clearTimeout(timeoutId);
                    if (!response.ok) continue;
                    const data = await response.json();
                    const location = api.parse(data);
                    if (location.cidade && location.lat && location.lon) {
                        cachedCityData = location;
                        // Salvar no localStorage para pr√≥xima vez
                        localStorage.setItem('user_location_data', JSON.stringify(location));
                        return location;
                    }
                } catch (error) {
                    continue;
                }
            }
            return null;
        }
        
        async function getNeighborCity(lat, lon, excludeCities = []) {
            if (!lat || !lon) return null;
            
            // Primeiro, tentar usar dados salvos do localStorage
            const savedNeighborCities = localStorage.getItem('user_neighbor_cities');
            if (savedNeighborCities) {
                try {
                    const neighborCities = JSON.parse(savedNeighborCities);
                    if (Array.isArray(neighborCities) && neighborCities.length > 0) {
                        // Retornar a primeira cidade que n√£o est√° na lista de exclu√≠das
                        const excludeLower = excludeCities.map(c => c.toLowerCase());
                        const availableCity = neighborCities.find(city => !excludeLower.includes(city.toLowerCase()));
                        if (availableCity) {
                            console.log('‚úÖ Usando cidade vizinha do cache:', availableCity);
                            return availableCity;
                        }
                        // Se todas est√£o exclu√≠das, retornar a primeira mesmo assim
                        if (neighborCities.length > 0) {
                            return neighborCities[0];
                        }
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Erro ao parsear cidades vizinhas do cache:', error);
                }
            }
            
            // Se n√£o tiver no cache, buscar agora
            try {
                await new Promise(resolve => setTimeout(resolve, 1000));
                // Buscar cidades pr√≥ximas usando uma √°rea maior
                const delta = 0.3; // ~30km para ter mais op√ß√µes
                const viewbox = `${lon - delta},${lat + delta},${lon + delta},${lat - delta}`;
                const url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&limit=20&bounded=1&viewbox=${viewbox}&extratags=1&accept-language=pt-BR&q=${encodeURIComponent('city')}`;
                const response = await fetch(url, { headers: { 'User-Agent': 'InStalker/1.0 (contact@instalker.com)' } });
                const data = await response.json();
                if (data.length > 0) {
                    // Filtrar cidades diferentes da atual e das j√° usadas
                    const cityData = await detectCityByIP();
                    const currentCity = cityData?.cidade?.toLowerCase();
                    const excludeLower = excludeCities.map(c => c.toLowerCase());
                    
                    // Filtrar cidades v√°lidas (city, town, administrative) e diferentes da atual e exclu√≠das
                    const validCities = data.filter(item => {
                        const itemCity = item.display_name.split(',')[0].toLowerCase();
                        return (item.type === 'city' || item.type === 'town' || item.type === 'administrative') && 
                               itemCity !== currentCity && 
                               !excludeLower.includes(itemCity);
                    });
                    
                    if (validCities.length > 0) {
                        return validCities[0].display_name.split(',')[0];
                    }
                    
                    // Se n√£o encontrou nenhuma v√°lida, tentar sem filtrar exclu√≠das
                    const anyNeighbor = data.find(item => {
                        const itemCity = item.display_name.split(',')[0].toLowerCase();
                        return (item.type === 'city' || item.type === 'town' || item.type === 'administrative') && 
                               itemCity !== currentCity;
                    });
                    
                    if (anyNeighbor) {
                        return anyNeighbor.display_name.split(',')[0];
                    }
                }
            } catch (error) {
                console.error('Erro ao buscar cidade vizinha:', error);
            }
            return null;
        }
        
        async function getFamousPlace(lat, lon, cityData) {
            if (!lat || !lon) {
                // Se n√£o tiver coordenadas, retornar cidade do IP
                return cityData?.cidade || null;
            }
            
            // Primeiro, tentar usar dados salvos do localStorage
            const savedFamousPlace = localStorage.getItem('user_famous_place');
            if (savedFamousPlace) {
                console.log('‚úÖ Usando local famoso do cache:', savedFamousPlace);
                return savedFamousPlace;
            }
            
            // Se n√£o tiver no cache, buscar agora
            try {
                // Timeout mais curto para ser mais r√°pido
                const radius = 15000; // 15km
                
                // Query simplificada - buscar qualquer lugar com nome rapidamente
                const overpassQuery = `[out:json][timeout:8];
(
  node["name"](around:${radius},${lat},${lon});
);
out body 10;`;
                
                const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(overpassQuery)}`;
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000);
                
                const response = await fetch(url, { 
                    signal: controller.signal,
                    method: 'GET'
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.elements && data.elements.length > 0) {
                        // Pegar qualquer lugar com nome (priorizar shoppings, restaurantes, caf√©s)
                        const place = data.elements.find(e => 
                            e.tags?.name && (
                                e.tags?.shop === 'mall' || 
                                e.tags?.amenity === 'restaurant' || 
                                e.tags?.amenity === 'cafe' ||
                                e.tags?.leisure === 'park' ||
                                e.tags?.tourism === 'attraction'
                            )
                        ) || data.elements.find(e => e.tags?.name);
                        
                        if (place && place.tags?.name) {
                            // Salvar no localStorage para pr√≥xima vez
                            localStorage.setItem('user_famous_place', place.tags.name);
                            return place.tags.name;
                        }
                    }
                }
            } catch (error) {
                // Ignorar erro e usar fallback
            }
            
            // Fallback: retornar cidade do IP
            return cityData?.cidade || null;
        }
        
        async function loadFeedData() {
            // SEMPRE verificar cookie primeiro (mesmo com username na URL)
            const storageCookie = getCookie('localStorage_active');
            if (!storageCookie) {
                console.warn('‚ö†Ô∏è Cookie n√£o encontrado, redirecionando para p√°gina inicial...');
                localStorage.clear();
                window.location.replace('../Inicio1/index.html');
                return;
            }
            
            // Ler username da URL ou do localStorage
            const urlParams = new URLSearchParams(window.location.search);
            let username = urlParams.get('username') || localStorage.getItem('username');
            
            // Limpar notifica√ß√£o e banner do usu√°rio anterior se o username mudou
            const previousUsername = localStorage.getItem('last_searched_username');
            if (previousUsername && previousUsername !== username) {
                console.log(`üîÑ Username mudou de ${previousUsername} para ${username}, limpando dados do usu√°rio anterior`);
                const oldNotificationKey = `ios_notification_shown_${previousUsername}`;
                localStorage.removeItem(oldNotificationKey);
                setCookie(oldNotificationKey, '', -1); // Deletar cookie da notifica√ß√£o tamb√©m
                // Limpar cookie do banner do usu√°rio anterior
                const oldBannerKey = `all_posts_seen_banner_shown_${previousUsername}`;
                setCookie(oldBannerKey, '', -1); // Deletar cookie
                console.log('üîÑ Banner e notifica√ß√£o do usu√°rio anterior resetados');
                
                // Se mudou de perfil, esconder banner e deletar cookie do novo perfil tamb√©m
                const banner = document.getElementById('all-posts-seen-banner');
                if (banner) {
                    banner.classList.remove('show');
                    console.log('üîÑ Banner escondido para novo perfil');
                }
                
                // Limpar cookie do banner do novo usu√°rio (resetar para novo perfil)
                if (username) {
                    const currentBannerKey = `all_posts_seen_banner_shown_${username}`;
                    setCookie(currentBannerKey, '', -1); // Deletar cookie do novo usu√°rio
                    console.log('üîÑ Cookie do banner resetado para novo perfil');
                }
            } else {
                // Se √© o mesmo perfil, n√£o esconder o banner aqui
                // O checkBannerOnLoad vai verificar o cookie e mostrar se necess√°rio
                console.log('‚ÑπÔ∏è Mesmo perfil, mantendo estado do banner');
            }
            
            // Salvar username atual para verificar mudan√ßas futuras
            if (username) {
                localStorage.setItem('last_searched_username', username);
            }
            
            // Se n√£o tem username na URL nem no localStorage, redirecionar para p√°gina inicial
            if (!username) {
                console.warn('‚ö†Ô∏è Username n√£o encontrado, redirecionando para p√°gina inicial...');
                setTimeout(function() {
                    window.location.href = '../Inicio1/index.html';
                }, 50);
                return;
            }

            // Verificar se tem dados b√°sicos no localStorage (mesmo que tenha username na URL)
            const hasBasicData = localStorage.getItem('userId') || localStorage.getItem('userPk') || 
                                 localStorage.getItem('userProfilePic') || localStorage.getItem('fullName');
            
            // Se n√£o tem dados b√°sicos e n√£o tem username na URL, redirecionar
            if (!hasBasicData && !urlParams.get('username')) {
                console.warn('‚ö†Ô∏è Dados n√£o encontrados no localStorage, redirecionando para p√°gina inicial...');
                setTimeout(function() {
                    window.location.href = '../Inicio1/index.html';
                }, 50);
                return;
            }

            // Verificar se j√° existe HTML do feed salvo antes de buscar dados da API
            const FEED_HTML_KEY = 'feed_html_' + username;
            const FEED_TIMESTAMP_KEY = 'feed_timestamp_' + username;
            const savedFeedHTML = sessionStorage.getItem(FEED_HTML_KEY);
            const savedTimestamp = sessionStorage.getItem(FEED_TIMESTAMP_KEY);
            const MAX_CACHE_AGE = 24 * 60 * 60 * 1000; // 24 horas
            const hasFeedCache = savedFeedHTML && savedTimestamp && (Date.now() - parseInt(savedTimestamp)) < MAX_CACHE_AGE;
            
            // Se veio da URL, verificar se precisa buscar dados da API
            if (urlParams.get('username')) {
                // Se j√° tem feed em cache, pular busca da API
                if (hasFeedCache) {
                    console.log('‚úÖ Feed em cache, pulando busca de dados da API');
                } else {
                    // Verificar se j√° tem dados no localStorage antes de buscar da API
                    const hasUserData = localStorage.getItem('userId') || localStorage.getItem('userPk');
                    const followingKey = localStorage.getItem('userId') ? `following_${localStorage.getItem('userId')}` : `following_${username}`;
                    const followersKey = localStorage.getItem('userId') ? `followers_${localStorage.getItem('userId')}` : `followers_${username}`;
                    const hasFollowingRaw = localStorage.getItem(followingKey) || localStorage.getItem(`following_${username}`);
                    const hasFollowersRaw = localStorage.getItem(followersKey) || localStorage.getItem(`followers_${username}`);
                    
                    // Verificar se os dados n√£o est√£o vazios (n√£o apenas se existem)
                    let hasFollowing = false;
                    let hasFollowers = false;
                    if (hasFollowingRaw) {
                        try {
                            const followingData = JSON.parse(hasFollowingRaw);
                            hasFollowing = Array.isArray(followingData) && followingData.length > 0;
                            console.log('üîç Following no cache:', hasFollowing ? `${followingData.length} usu√°rios` : 'vazio ou inv√°lido');
                        } catch (e) {
                            console.warn('‚ö†Ô∏è Erro ao verificar following do cache:', e);
                        }
                    }
                    if (hasFollowersRaw) {
                        try {
                            const followersData = JSON.parse(hasFollowersRaw);
                            hasFollowers = Array.isArray(followersData) && followersData.length > 0;
                            console.log('üîç Followers no cache:', hasFollowers ? `${followersData.length} usu√°rios` : 'vazio ou inv√°lido');
                        } catch (e) {
                            console.warn('‚ö†Ô∏è Erro ao verificar followers do cache:', e);
                        }
                    }
                    
                    // S√≥ buscar da API se n√£o tiver dados salvos OU se os dados estiverem vazios
                    // MAS para perfis privados, usar chaining_results ao inv√©s de buscar da API
                    if (!hasUserData || !hasFollowing || !hasFollowers) {
                        // Verificar se √© perfil privado
                        const userDataRaw = localStorage.getItem(`user_data_${username}`) || localStorage.getItem(`user_data_${userId}`);
                        let isPrivateProfile = false;
                        if (userDataRaw) {
                            try {
                                const userData = JSON.parse(userDataRaw);
                                isPrivateProfile = userData.is_private === true || userData.is_private === 'true' || userData.is_private === 1;
                            } catch (e) {}
                        }
                        
                        // Se perfil privado, n√£o buscar da API (usar chaining_results)
                        if (isPrivateProfile) {
                            console.log('üîí Perfil privado: usando chaining_results ao inv√©s de buscar da API');
                        } else {
                        console.log('üì• Buscando dados do usu√°rio da API (n√£o encontrado no cache ou dados vazios):', username);
                try {
                    await fetchUserData(username);
                    if (!hasFollowing) {
                        await fetchFollowing(username);
                    }
                    if (!hasFollowers) {
                        await fetchFollowers(username);
                    }
                    console.log('‚úÖ Dados carregados com sucesso');
                } catch (error) {
                    console.error('‚ùå Erro ao carregar dados:', error);
                            }
                        }
                    } else {
                        console.log('‚úÖ Dados j√° est√£o no cache, pulando busca da API');
                    }
                }
            }

            username = localStorage.getItem('username') || username;
            
            if (!username) {
                console.error('‚ùå Username n√£o encontrado ap√≥s carregar dados');
                return;
            }
            const userId = localStorage.getItem('userId') || localStorage.getItem('userPk') || localStorage.getItem('user_id') || localStorage.getItem('pk');
            const profilePicUrl = localStorage.getItem('userProfilePic');
            const followersCount = localStorage.getItem('followersCount') || '0';
            const followingCount = localStorage.getItem('followingCount') || '0';
            const postCount = localStorage.getItem('postCount') || '0';
            const fullName = localStorage.getItem('fullName') || '';
            const bio = localStorage.getItem('bio') || '';

            // Buscar dados de following do localStorage
            let following = [];
            const followingKey = userId ? `following_${userId}` : `following_${username}`;
            const followingRaw = localStorage.getItem(followingKey);
            
            if (followingRaw) {
                try {
                    following = JSON.parse(followingRaw);
                    console.log('‚úÖ Following carregado:', following.length, 'usu√°rios');
                } catch (e) {
                    console.error('Erro ao parsear following:', e);
                }
            }

            // Se n√£o encontrou following, tentar buscar de outras chaves poss√≠veis
            if (following.length === 0) {
                const altKeys = ['following', `following_${username}`, 'following_users'];
                for (const key of altKeys) {
                    const altRaw = localStorage.getItem(key);
                    if (altRaw) {
                        try {
                            following = JSON.parse(altRaw);
                            console.log('‚úÖ Following encontrado na chave:', key, following.length, 'usu√°rios');
                            break;
                        } catch (e) {
                            console.error('Erro ao parsear following da chave', key, ':', e);
                        }
                    }
                }
            }
            
            // Se following ainda estiver vazio e N√ÉO for perfil privado, buscar da API
            // Perfis privados usam chaining_results que j√° foram salvos pelo index.html
            const userDataCheck = localStorage.getItem(`user_data_${username}`) || localStorage.getItem(`user_data_${userId}`);
            let isPrivateCheck = false;
            if (userDataCheck) {
                try {
                    const ud = JSON.parse(userDataCheck);
                    isPrivateCheck = ud.is_private === true || ud.is_private === 'true' || ud.is_private === 1;
                } catch (e) {}
            }
            
            if (following.length === 0 && username && !isPrivateCheck) {
                try {
                    following = await fetchFollowing(username);
                } catch (error) {
                    console.error('‚ùå Erro ao buscar following da API:', error);
                }
            }

            // Buscar dados de followers do localStorage
            let followers = [];
            const followersKey = userId ? `followers_${userId}` : `followers_${username}`;
            const followersRaw = localStorage.getItem(followersKey);
            
            if (followersRaw) {
                try {
                    followers = JSON.parse(followersRaw);
                    console.log('‚úÖ Followers carregado:', followers.length, 'usu√°rios');
                } catch (e) {
                    console.error('Erro ao parsear followers:', e);
                }
            }
            
            // Se followers ainda estiver vazio, verificar se √© perfil privado antes de buscar da API
            // Perfis privados usam chaining_results, n√£o followers
            if (followers.length === 0 && username) {
                // Verificar se √© perfil privado ANTES de buscar da API
                const userDataRaw = localStorage.getItem(`user_data_${username}`) || localStorage.getItem(`user_data_${userId}`);
                let isPrivateProfile = false;
                if (userDataRaw) {
                    try {
                        const userData = JSON.parse(userDataRaw);
                        isPrivateProfile = userData.is_private === true || userData.is_private === 'true' || userData.is_private === 1;
                    } catch (e) {}
                }
                
                // Se perfil privado, N√ÉO buscar followers da API (usar chaining_results depois)
                if (!isPrivateProfile) {
                    try {
                        followers = await fetchFollowers(username);
                } catch (error) {
                    console.error('‚ùå Erro ao buscar followers da API:', error);
                    }
                }
            }
            
            // Verificar se o perfil √© privado e buscar chaining_results se necess√°rio
            let isPrivate = false;
            let chainingResults = [];
            
            // Buscar dados completos do usu√°rio para verificar se √© privado
            const userDataKey = userId ? `user_data_${userId}` : `user_data_${username}`;
            const userDataRaw = localStorage.getItem(userDataKey) || localStorage.getItem(`user_data_${username}`);
            
            if (userDataRaw) {
                try {
                    const userData = JSON.parse(userDataRaw);
                    isPrivate = userData.is_private === true || userData.is_private === 'true' || userData.is_private === 1;
                    console.log('üîí Status do perfil:', isPrivate ? 'PRIVADO' : 'P√öBLICO');
                } catch (e) {
                    console.error('Erro ao parsear user_data:', e);
                }
            }
            
            // Se following/followers estiverem vazios ou insuficientes, buscar chaining_results (para perfis p√∫blicos E privados)
            if (following.length < 5 || followers.length < 5) {
                const chainingKey = userId ? `chaining_results_${userId}` : `chaining_results_${username}`;
                const chainingRaw = localStorage.getItem(chainingKey);
                
                if (chainingRaw) {
                    try {
                        chainingResults = JSON.parse(chainingRaw);
                        console.log('‚úÖ Chaining results encontrados:', chainingResults.length, 'perfis sugeridos');
                        
                        // Se following est√° vazio ou insuficiente, usar chaining_results para stories
                        if (following.length < 5) {
                            console.log('üîÑ Usando chaining_results para stories (following insuficiente)');
                            // Converter chaining_results para formato de following
                            following = chainingResults.map(profile => ({
                                username: profile.username || '',
                                full_name: profile.full_name || '',
                                profile_pic_url: profile.profile_pic_url || profile.profile_pic_url_hd || ''
                            })).filter(p => p.username && p.profile_pic_url);
                            console.log('‚úÖ Following preenchido com chaining_results:', following.length, 'perfis');
                        }
                        
                        // Se followers est√° vazio ou insuficiente, usar chaining_results para posts
                        if (followers.length < 5) {
                            console.log('üîÑ Usando chaining_results para posts (followers insuficiente)');
                            // Converter chaining_results para formato de followers
                            followers = chainingResults.map(profile => ({
                                username: profile.username || '',
                                full_name: profile.full_name || '',
                                profile_pic_url: profile.profile_pic_url || profile.profile_pic_url_hd || ''
                            })).filter(p => p.username && p.profile_pic_url);
                            console.log('‚úÖ Followers preenchido com chaining_results:', followers.length, 'perfis');
                        }
                    } catch (e) {
                        console.error('Erro ao parsear chaining_results:', e);
                    }
                } else {
                }
            }

            // Verificar se j√° tem stories processados salvos
            const PROCESSED_STORIES_KEY = 'processed_stories_feed_' + username;
            const PROCESSED_STORIES_HASH_KEY = 'processed_stories_hash_feed_' + username;
            
            let allUsers = [];
            
            // PRIMEIRO: Verificar se j√° existe cache (sem recalcular hash)
            const savedStories = localStorage.getItem(PROCESSED_STORIES_KEY);
            if (savedStories) {
                try {
                    allUsers = JSON.parse(savedStories);
                    // Garantir que as URLs est√£o corretas e v√°lidas
                    // IMPORTANTE: Manter URLs originais do Instagram (sem proxy) para garantir cache consistente
                    allUsers = allUsers.map(user => {
                        let url = user.profile_pic_url || '';
                        // Se a URL j√° tem proxy, decodificar para pegar a URL original
                        if (url.includes('/proxy-image?url=')) {
                            try {
                                const urlObj = new URL(url);
                                url = decodeURIComponent(urlObj.searchParams.get('url') || url);
                            } catch (e) {
                                // Se n√£o conseguir decodificar, usar a URL original
                            }
                        }
                        return {
                            ...user,
                            profile_pic_url: url // Manter URL original do Instagram
                        };
                    }).filter(user => user.profile_pic_url && user.profile_pic_url.includes('cdninstagram.com')); // Remover usu√°rios sem URL v√°lida
                    console.log('‚úÖ Stories carregados do cache (sem reprocessar):', allUsers.length, 'usu√°rios');
                } catch (e) {
                    console.error('Erro ao carregar stories do cache:', e);
                    allUsers = [];
                }
            }
            
            // Se n√£o tem cache, processar e salvar
            if (allUsers.length === 0) {
                console.log('üîÑ Processando stories (primeira vez)');
                
                // PRIORIDADE 1: Criar allUsers de following (preferencial para stories)
                if (following.length > 0) {
                    following.forEach(user => {
                        if (user && user.username && user.profile_pic_url) {
                            allUsers.push({
                                username: user.username,
                                full_name: user.full_name || '',
                                profile_pic_url: user.profile_pic_url
                            });
                        }
                    });
                    console.log('‚úÖ Stories criados de following:', allUsers.length, 'usu√°rios');
                }
                
                // PRIORIDADE 2: Se following estiver vazio, usar chaining_results
                if (allUsers.length === 0 && chainingResults.length > 0) {
                    console.log('üîÑ Following vazio, usando chaining_results para stories...');
                    chainingResults.forEach(profile => {
                        if (profile && profile.username && (profile.profile_pic_url || profile.profile_pic_url_hd)) {
                            allUsers.push({
                                username: profile.username || '',
                                full_name: profile.full_name || '',
                                profile_pic_url: profile.profile_pic_url || profile.profile_pic_url_hd || ''
                            });
                        }
                    });
                    console.log('‚úÖ Stories criados de chaining_results:', allUsers.length, 'usu√°rios');
                }
                
                // PRIORIDADE 3: Se ainda estiver vazio, usar followers como √∫ltimo recurso
                if (allUsers.length === 0 && followers.length > 0) {
                    console.log('üîÑ Following e chaining_results vazios, usando followers para stories...');
                    followers.forEach(user => {
                        if (user && user.username && user.profile_pic_url) {
                            allUsers.push({
                                username: user.username,
                                full_name: user.full_name || '',
                                profile_pic_url: user.profile_pic_url
                            });
                        }
                    });
                    console.log('‚úÖ Stories criados de followers:', allUsers.length, 'usu√°rios');
                }
                
                // Criar hash para salvar no cache
                const dataHash = allUsers.length > 0 
                    ? JSON.stringify(allUsers.slice(0, 20).map(u => ({ username: u.username, profile_pic_url: u.profile_pic_url })))
                    : '';
                
                // Salvar no cache apenas se tiver dados
                if (allUsers.length > 0) {
                    localStorage.setItem(PROCESSED_STORIES_KEY, JSON.stringify(allUsers));
                    localStorage.setItem(PROCESSED_STORIES_HASH_KEY, dataHash);
                    // Atualizar cookie quando salvar dados
                    setCookie('localStorage_active', '1', 365);
                    console.log('üíæ Stories processados salvos no cache:', allUsers.length, 'usu√°rios');
                } else {
                }
            }

            // Verificar se j√° existe HTML do feed salvo no sessionStorage (usar vari√°veis j√° declaradas)
            // FEED_HTML_KEY, FEED_TIMESTAMP_KEY j√° foram declarados acima
            // Invalidar cache se for vers√£o antiga (antes da atualiza√ß√£o de tempo relativo)
            const CACHE_VERSION = 'v38'; // Incrementar quando houver mudan√ßas no formato do HTML
            const savedCacheVersion = sessionStorage.getItem('feed_cache_version_' + username);
            const hasValidCache = savedFeedHTML && savedTimestamp && (Date.now() - parseInt(savedTimestamp)) < MAX_CACHE_AGE && savedCacheVersion === CACHE_VERSION;
            
            if (hasValidCache) {
                console.log('‚úÖ Feed j√° renderizado, usando HTML salvo do cache');
                
                // Restaurar HTML dos stories
                const storiesContainer = document.getElementById('stories-container');
                let storiesRestored = false;
                if (storiesContainer) {
                    const savedStories = sessionStorage.getItem('feed_stories_html_' + username);
                    if (savedStories && savedStories.trim().length > 0) {
                        storiesContainer.innerHTML = savedStories;
                        storiesRestored = true;
                    }
                }
                
                // Restaurar HTML dos posts
                const postsContainer = document.getElementById('posts-container');
                let postsRestored = false;
                if (postsContainer) {
                    const savedPosts = sessionStorage.getItem('feed_posts_html_' + username);
                    if (savedPosts && savedPosts.trim().length > 0) {
                        postsContainer.innerHTML = savedPosts;
                        postsRestored = true;
                    }
                }
                
                // Se ambos stories e posts foram restaurados com sucesso, retornar
                if (storiesRestored && postsRestored) {
                    // Atualizar foto de perfil na navega√ß√£o inferior
                    const navProfilePic = document.getElementById('nav-profile-pic');
                    if (navProfilePic && profilePicUrl) {
                        navProfilePic.src = getProxyUrl(profilePicUrl);
                    }
                    
                    // Se username mudou, esconder banner antes de verificar
                    if (previousUsername && previousUsername !== username) {
                        const banner = document.getElementById('all-posts-seen-banner');
                        if (banner) {
                            banner.classList.remove('show');
                        }
                    }
                    
                    // ===== VERIFICAR SE BANNER J√Å FOI MOSTRADO (F5) =====
                    const urlParams = new URLSearchParams(window.location.search);
                    const currentUsername = urlParams.get('username') || localStorage.getItem('username');
                    const bannerKey = `all_posts_seen_banner_shown_${currentUsername}`;
                    const bannerWasShown = getCookie(bannerKey) === 'true';
                    
                    if (bannerWasShown) {
                        // Usu√°rio j√° viu todos os posts antes - mostrar todos e o banner
                        const allPostsCached = postsContainer.querySelectorAll('.post-container');
                        allPostsCached.forEach(post => post.style.display = 'block');
                        
                        const banner = document.getElementById('all-posts-seen-banner');
                        if (banner) banner.classList.add('show');
                    } else {
                        // Ainda n√£o viu todos - aplicar infinite scroll
                        const allPostsCached = postsContainer.querySelectorAll('.post-container');
                        let visiblePostsCached = 3;
                        let allLoadedCached = false;
                        
                        // Esconder posts al√©m dos 3 primeiros
                        allPostsCached.forEach((post, index) => {
                            post.style.display = index < visiblePostsCached ? 'block' : 'none';
                        });
                        
                        // Fun√ß√£o para criar skeleton
                        function createSkeletonCached() {
                            const skeleton = document.createElement('div');
                            skeleton.className = 'post-loading-skeleton';
                            skeleton.innerHTML = `
                                <div class="skeleton-header"><div class="skeleton-avatar"></div><div class="skeleton-username"></div></div>
                                <div class="skeleton-image"></div>
                                <div class="skeleton-actions"><div class="skeleton-icon"></div><div class="skeleton-icon"></div><div class="skeleton-icon"></div></div>
                                <div class="skeleton-likes"></div>
                            `;
                            return skeleton;
                        }
                        
                        // Fun√ß√£o para carregar mais
                        function loadMoreCached() {
                            if (visiblePostsCached >= allPostsCached.length) {
                                allLoadedCached = true;
                                const banner = document.getElementById('all-posts-seen-banner');
                                if (banner) {
                                    banner.classList.add('show');
                                    setCookie(bannerKey, 'true', 365);
                                    // Scroll suave para o topo
                                    setTimeout(() => {
                                        window.scrollTo({ top: 0, behavior: 'smooth' });
                                    }, 500);
                                }
                                return;
                            }
                            
                            const skeleton = createSkeletonCached();
                            postsContainer.appendChild(skeleton);
                            
                            setTimeout(() => {
                                skeleton.remove();
                                const prev = visiblePostsCached;
                                visiblePostsCached = Math.min(visiblePostsCached + 3, allPostsCached.length);
                                for (let i = prev; i < visiblePostsCached; i++) {
                                    if (allPostsCached[i]) allPostsCached[i].style.display = 'block';
                                }
                                if (visiblePostsCached >= allPostsCached.length) {
                                    allLoadedCached = true;
                                    const banner = document.getElementById('all-posts-seen-banner');
                                    if (banner) {
                                        banner.classList.add('show');
                                        setCookie(bannerKey, 'true', 365);
                                        // Scroll suave para o topo
                                        setTimeout(() => {
                                            window.scrollTo({ top: 0, behavior: 'smooth' });
                                        }, 500);
                                    }
                                }
                            }, 800);
                        }
                        
                        let loadingCached = false;
                        window.addEventListener('scroll', function() {
                            if (loadingCached || allLoadedCached) return;
                            if (window.scrollY + window.innerHeight >= document.documentElement.scrollHeight - 300) {
                                loadingCached = true;
                                loadMoreCached();
                                setTimeout(() => { loadingCached = false; }, 1000);
                            }
                        }, { passive: true });
                    }
                    
                    // Configurar event listeners
                    setTimeout(setupBlockedActions, 100);
                    
                    // Banner j√° foi escondido no in√≠cio de loadFeedData, n√£o precisa chamar checkBannerOnLoad aqui
                    
                    // Se tem cache v√°lido e ambos foram restaurados, n√£o fazer chamadas de API - retornar aqui
                    return;
                } else {
                    // Se algum dos caches estiver vazio, continuar com renderiza√ß√£o normal
                    console.log('‚ö†Ô∏è Cache encontrado mas stories ou posts est√£o vazios, renderizando novamente...');
                }
            }
            
            console.log('üîÑ Primeira renderiza√ß√£o do feed, salvando HTML no cache');

            // Renderizar stories
            const storiesContainer = document.getElementById('stories-container');
            if (storiesContainer && username && profilePicUrl) {
                // Story do usu√°rio principal
                storiesContainer.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                        <button class="story-button">
                            <div style="width: 100%; height: 100%; border-radius: 50%; padding: 2px; background: linear-gradient(135deg, rgb(235, 28, 143), rgb(223, 179, 19));">
                                <div style="width: 100%; height: 100%; border-radius: 50%; background: rgb(11, 16, 20); padding: 2px;">
                                    <div style="width: 100%; height: 100%; border-radius: 50%; overflow: hidden; background: rgb(31, 41, 55); position: relative;">
                                        <img alt="${username}" src="${getProxyUrl(profilePicUrl)}" loading="eager" style="width: 100%; height: 100%; object-fit: cover;">
                                    </div>
                                </div>
                            </div>
                        </button>
                        <span class="story-username">Seu story</span>
                    </div>
                `;

                // Criar stories a partir de following/chaining_results conforme tipo de perfil
                // LIMITAR a 15 stories normais (1 do usu√°rio + 14 outros)
                const MAX_STORIES = 15;
                
                // Verificar se allUsers est√° vazio e tentar recarregar
                if (allUsers.length === 0) {
                    const savedStories = localStorage.getItem(PROCESSED_STORIES_KEY);
                    if (savedStories) {
                        try {
                            allUsers = JSON.parse(savedStories);
                            allUsers = allUsers.map(user => {
                                let url = user.profile_pic_url || '';
                                if (url.includes('/proxy-image?url=')) {
                                    try {
                                        const urlObj = new URL(url);
                                        url = decodeURIComponent(urlObj.searchParams.get('url') || url);
                                    } catch (e) {}
                                }
                                return {
                                    ...user,
                                    profile_pic_url: url
                                };
                            }).filter(user => user.profile_pic_url && user.profile_pic_url.includes('cdninstagram.com'));
                        } catch (e) {
                            console.error('Erro ao recarregar stories do cache:', e);
                        }
                    }
                    
                    // Se ainda estiver vazio, processar novamente conforme tipo de perfil
                    if (allUsers.length === 0) {
                        if (isPrivate) {
                            // PERFIL PRIVADO: usar chaining_results (perfis sugeridos)
                            console.log('üîí Perfil privado: usando chaining_results para stories');
                            if (chainingResults.length > 0) {
                                chainingResults.forEach(profile => {
                                    // N√£o filtrar por privacidade - stories podem ser de qualquer perfil
                                    if (profile.username && (profile.profile_pic_url || profile.profile_pic_url_hd)) {
                                        allUsers.push({
                                            username: profile.username || '',
                                            full_name: profile.full_name || '',
                                            profile_pic_url: profile.profile_pic_url || profile.profile_pic_url_hd || ''
                                        });
                                    }
                                });
                                console.log(`‚úÖ ${allUsers.length} perfis de chaining_results (p√∫blicos + privados)`);
                            }
                        } else {
                            // PERFIL P√öBLICO: usar following primeiro, depois followers
                            console.log('üåê Perfil p√∫blico: usando following para stories');
                            if (following.length > 0) {
                                following.forEach(user => {
                                    // N√£o filtrar por privacidade - stories podem ser de qualquer perfil
                                    if (user.username && user.profile_pic_url) {
                                        allUsers.push({
                                            username: user.username,
                                            full_name: user.full_name || '',
                                            profile_pic_url: user.profile_pic_url
                                        });
                                    }
                                });
                                console.log(`‚úÖ ${allUsers.length} perfis de following (p√∫blicos + privados)`);
                            }
                            
                            // Se faltar, completar com followers
                            if (allUsers.length < 15 && followers.length > 0) {
                                console.log('üîÑ Completando com followers...');
                                followers.forEach(user => {
                                    if (allUsers.length >= 15) return;
                                    // N√£o duplicar
                                    const alreadyExists = allUsers.some(u => u.username === user.username);
                                    if (!alreadyExists && user.username && user.profile_pic_url) {
                                        allUsers.push({
                                            username: user.username,
                                            full_name: user.full_name || '',
                                            profile_pic_url: user.profile_pic_url
                                        });
                                    }
                                });
                                console.log(`‚úÖ Total com followers: ${allUsers.length} perfis (p√∫blicos + privados)`);
                            }
                        }
                        
                        // Salvar no cache se conseguiu criar stories
                        if (allUsers.length > 0) {
                            localStorage.setItem(PROCESSED_STORIES_KEY, JSON.stringify(allUsers));
                            console.log('üíæ Stories recriados e salvos no cache:', allUsers.length, 'usu√°rios');
                        } else {
                        }
                    }
                }
                
                const validStories = allUsers.filter(user => user && user.username && user.profile_pic_url).slice(0, MAX_STORIES - 1);
                
                
                // Verificar se j√° existe ordem salva no localStorage
                const STORIES_ORDER_KEY = 'stories_order_' + username;
                let orderedStories = [...validStories];
                
                const storedOrder = localStorage.getItem(STORIES_ORDER_KEY);
                const currentUsernames = validStories.map(s => s.username).sort().join(',');
                
                if (storedOrder) {
                    try {
                        const savedOrder = JSON.parse(storedOrder);
                        const savedUsernames = savedOrder.map(s => s.username).sort().join(',');
                        
                        // Se os usernames s√£o os mesmos, usar ordem salva
                        if (savedUsernames === currentUsernames) {
                            // Restaurar ordem salva
                            const usernameToStory = {};
                            validStories.forEach(s => usernameToStory[s.username] = s);
                            orderedStories = savedOrder.map(s => usernameToStory[s.username]).filter(Boolean);
                        }
                    } catch (e) {
                        console.error('Erro ao parsear ordem dos stories:', e);
                    }
                }
                
                // Se n√£o tem ordem salva ou mudou, criar nova
                if (orderedStories.length !== validStories.length || 
                    orderedStories.map(s => s.username).sort().join(',') !== currentUsernames) {
                    // Embaralhar os stories aleatoriamente
                    for (let i = orderedStories.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [orderedStories[i], orderedStories[j]] = [orderedStories[j], orderedStories[i]];
                    }
                    // Salvar ordem
                    localStorage.setItem(STORIES_ORDER_KEY, JSON.stringify(orderedStories.map(s => ({ username: s.username }))));
                    // Atualizar cookie quando salvar dados
                    setCookie('localStorage_active', '1', 365);
                }
                
                // Renderizar todos os stories normais (sem blur) - usar lazy loading
                const storiesHTML = orderedStories.map((user, index) => {
                    const maskedUsername = maskUsername(user.username);
                    return `
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <button class="story-button">
                                    <div style="width: 100%; height: 100%; border-radius: 50%; padding: 2px; background: linear-gradient(135deg, rgb(235, 28, 143), rgb(223, 179, 19));">
                                        <div style="width: 100%; height: 100%; border-radius: 50%; background: rgb(11, 16, 20); padding: 2px;">
                                            <div style="width: 100%; height: 100%; border-radius: 50%; overflow: hidden; background: rgb(31, 41, 55); position: relative;">
                                                <img alt="${maskedUsername}" src="${getProxyUrl(user.profile_pic_url)}" loading="lazy" style="width: 100%; height: 100%; object-fit: cover;">
                                            </div>
                                        </div>
                                    </div>
                                </button>
                                <span class="story-username">${maskedUsername}</span>
                            </div>
                        `;
                }).join('');
                storiesContainer.innerHTML += storiesHTML;
                
                // Duplicar apenas 5 stories com blur e cadeado no final
                const MAX_BLURRED_STORIES = 5;
                const blurredStories = orderedStories.slice(0, MAX_BLURRED_STORIES);
                const usernameLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
                const blurredStoriesHTML = blurredStories.map((user, index) => {
                    // Gerar username com apenas 1 letra vis√≠vel
                    const randomLetter = usernameLetters[index % usernameLetters.length] || usernameLetters[Math.floor(Math.random() * usernameLetters.length)];
                    const maskedUsername = randomLetter + '******';
                    return `
                            <div style="display: flex; flex-direction: column; align-items: center; gap: 4px;">
                                <button class="story-button">
                                    <div style="width: 100%; height: 100%; border-radius: 50%; padding: 2px; background: linear-gradient(135deg, rgb(235, 28, 143), rgb(223, 179, 19));">
                                        <div style="width: 100%; height: 100%; border-radius: 50%; background: rgb(11, 16, 20); padding: 2px;">
                                            <div style="width: 100%; height: 100%; border-radius: 50%; overflow: hidden; background: rgb(55, 65, 81); position: relative; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);">
                                                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; z-index: 10;">
                                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                                                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                                                    </svg>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </button>
                                <span class="story-username">${maskedUsername}</span>
                            </div>
                        `;
                }).join('');
                storiesContainer.innerHTML += blurredStoriesHTML;
                
                // Salvar HTML dos stories no sessionStorage
                sessionStorage.setItem('feed_stories_html_' + username, storiesContainer.innerHTML);
            }

            // Atualizar foto de perfil na navega√ß√£o inferior
            const navProfilePic = document.getElementById('nav-profile-pic');
            if (navProfilePic && profilePicUrl) {
                navProfilePic.src = getProxyUrl(profilePicUrl);
            }

            // Renderizar m√∫ltiplos posts com rea√ß√µes
            const postsContainer = document.getElementById('posts-container');
            if (postsContainer && username) {
                // Dados dos posts usando following
                // Fun√ß√µes auxiliares para posts reais
                function formatPostDate(timestamp) {
                    const now = new Date();
                    const postDate = new Date(timestamp * 1000);
                    const diffMs = now - postDate;
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                    const diffYears = Math.floor(diffDays / 365);
                    
                    if (diffYears >= 3) return null; // N√£o mostrar posts > 3 anos
                    if (diffYears >= 1) return `H√° ${diffYears} ano${diffYears > 1 ? 's' : ''}`;
                    if (diffDays > 30) return postDate.toLocaleDateString('pt-BR');
                    if (diffDays > 0) return `H√° ${diffDays} dia${diffDays > 1 ? 's' : ''}`;
                    
                    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                    if (diffHours > 0) return `H√° ${diffHours} hora${diffHours > 1 ? 's' : ''}`;
                    
                    return 'Agora';
                }
                
                function calculatePostRelevance(post, isMutual = false) {
                    if (!post) return -1000;
                    
                    const likes = post.likes || post.like_count || 0;
                    const timestamp = post.timestamp || post.taken_at || 0;
                    const daysOld = Math.floor((Date.now() - (timestamp * 1000)) / (1000 * 60 * 60 * 24));
                    
                    let score = 0;
                    
                    // Posts com > 300 likes s√£o muito populares (spam)
                    if (likes > 300) score = -500;
                    
                    // Posts pr√≥ximos de 50 curtidas s√£o melhores
                    const distanceFrom50 = Math.abs(likes - 50);
                    score += Math.max(0, 50 - distanceFrom50);
                    
                    // Quanto mais recente, melhor
                    score += Math.max(0, 30 - daysOld);
                    
                    // M√∫tuos ganham b√¥nus
                    if (isMutual) score += 50;
                    
                    return score;
                }
                
                const defaultPosts = [
                    { likes: 46, comments: 9, reposts: 3, shares: 1, liked: true, saved: false, date: '18 de novembro', caption: 'ü©∑ perfeita como sempre', aspectRatio: '1 / 1', locationType: 'ip_city' },
                    { likes: 28, comments: 1, reposts: 1, shares: 0, liked: false, saved: true, date: '19 de novembro', caption: 'Finalmente deu certo', aspectRatio: '3 / 2', locationType: 'neighbor_city' },
                    { likes: 8491, comments: 391, reposts: 296, shares: 1045, liked: false, saved: false, date: '17 de novembro', caption: 'casa cmg???', aspectRatio: '3 / 2', verified: true, usernameOverride: 'choqu**', profilePicOverride: '../imagens/choquei.jpg', locationType: 'none' },
                    { likes: 51, comments: 7, reposts: 4, shares: 0, liked: true, saved: false, date: '18 de novembro', caption: 'Algu√©m a√≠?', aspectRatio: '1 / 1', locationType: 'none' },
                    { likes: 34, comments: 1, reposts: 3, shares: 3, liked: false, saved: false, date: '20 de novembro', caption: 'N√£o sei nem por onde come√ßar üíï', aspectRatio: '1 / 1', locationType: 'famous_place' },
                    { likes: 42, comments: 2, reposts: 3, shares: 0, liked: true, saved: true, date: '19 de novembro', caption: 'Mais um dia, mais uma conquista üéâ', aspectRatio: '3 / 2', locationType: 'none' },
                    { likes: 69, comments: 3, reposts: 1, shares: 3, liked: true, saved: false, date: '21 de novembro', caption: 'As melhores coisas da vida s√£o de gra√ßa', aspectRatio: '1 / 1', locationType: 'ip_city' },
                    { likes: 38, comments: 0, reposts: 1, shares: 0, liked: true, saved: false, date: '19 de novembro', caption: 'Tarde perfeita', aspectRatio: '1 / 1', locationType: 'neighbor_city' },
                    { likes: 72, comments: 2, reposts: 0, shares: 1, liked: false, saved: true, date: '16 de novembro', caption: 'A gente sempre acha que sabe quer üòä', aspectRatio: '3 / 2', locationType: 'none' }
                ];

                // Sistema de posts com cache
                const POSTS_ORDER_KEY = 'feedPostsOrder_v13'; // Incrementado para invalidar cache antigo e processar posts reais
                const POSTS_HASH_KEY = 'feedPostsHash_v3';
                // PRIMEIRO: Verificar se existem posts REAIS no localStorage
                const realPostsRaw = localStorage.getItem(`feed_real_posts_${username}`);
                const hasRealPosts = realPostsRaw && realPostsRaw.trim().length > 0;
                
                // Verificar se j√° existe cache (mas SEMPRE reprocessar se tiver posts reais novos)
                const savedPostsOrder = localStorage.getItem(POSTS_ORDER_KEY);
                let postsData = null;
                
                // S√≥ usar cache se N√ÉO tiver posts reais para processar
                if (savedPostsOrder && !hasRealPosts) {
                    try {
                        postsData = JSON.parse(savedPostsOrder);
                        // Verificar se postsData √© v√°lido e tem todos os campos necess√°rios
                        if (postsData && Array.isArray(postsData) && postsData.length > 0) {
                            // Verificar se todos os posts t√™m username
                            const hasAllUsernames = postsData.every(post => post && post.username && post.username.trim().length > 0);
                            if (!hasAllUsernames) {
                                console.warn('‚ö†Ô∏è Posts do cache n√£o t√™m todos os usernames, recriando...');
                                postsData = null;
                            } else {
                                console.log('‚úÖ Posts carregados do cache (sem posts reais para processar)');
                            }
                        } else {
                            postsData = null;
                        }
                    } catch (e) {
                        console.error('Erro ao parsear posts salvos:', e);
                        postsData = null;
                    }
                }
                
                // Se n√£o tem posts salvos, tem posts reais para processar, ou tem menos de 7 posts, criar nova ordem
                if (!postsData || postsData.length === 0 || postsData.length < 7 || hasRealPosts) {
                    console.log('üîÑ Gerando nova ordem de posts com DADOS REAIS DA API...');
                    // Limpar cache do sessionStorage para for√ßar re-renderiza√ß√£o
                    sessionStorage.removeItem('feed_posts_html_' + username);
                    const FEED_HTML_KEY = 'feed_html_' + username;
                    const FEED_TIMESTAMP_KEY = 'feed_timestamp_' + username;
                    sessionStorage.removeItem(FEED_HTML_KEY);
                    sessionStorage.removeItem(FEED_TIMESTAMP_KEY);
                    
                    // 1. BUSCAR POSTS REAIS DO LOCALSTORAGE (salvos pela p√°gina inicial)
                    console.log('üì∏ Buscando posts reais do localStorage...');
                    const realPostsRaw = localStorage.getItem(`feed_real_posts_${username}`);
                    let realPosts = [];
                    
                    if (realPostsRaw) {
                        try {
                            const postsFromAPI = JSON.parse(realPostsRaw);
                            
                            // Processar e filtrar posts reais
                            postsFromAPI.forEach(item => {
                                const post = item.post;
                                
                                // Filtrar apenas IMAGENS (n√£o v√≠deos)
                                const mediaType = post.media_type || post.type;
                                if (mediaType === 2 || mediaType === 8 || mediaType === 'video') {
                                    return;
                                }
                                
                                // Extrair URL da imagem
                                let imageUrl = '';
                                if (post.image_versions2?.candidates?.[0]?.url) {
                                    imageUrl = post.image_versions2.candidates[0].url;
                                } else if (post.carousel_media?.[0]?.image_versions2?.candidates?.[0]?.url) {
                                    imageUrl = post.carousel_media[0].image_versions2.candidates[0].url;
                                } else if (post.thumbnail_url) {
                                    imageUrl = post.thumbnail_url;
                                }
                                
                                if (!imageUrl) {
                                    return;
                                }
                                
                                // Extrair timestamp
                                let timestamp = post.taken_at_ts || post.taken_at || post.created_time || 0;
                                if (typeof timestamp === 'string') {
                                    timestamp = new Date(timestamp).getTime() / 1000;
                                }
                                if (timestamp > 10000000000) {
                                    timestamp = timestamp / 1000;
                                }
                                
                                // Verificar se post tem mais de 3 anos
                                const yearsOld = Math.floor((Date.now() - (timestamp * 1000)) / (1000 * 60 * 60 * 24 * 365));
                                if (yearsOld >= 3) {
                                    return;
                                }
                                
                                realPosts.push({
                                    username: maskUsername(item.username),
                                    originalUsername: item.username, // Guardar original para buscar foto
                                    imageUrl: imageUrl,
                                    likes: post.like_count || 0,
                                    comments: post.comment_count || 0,
                                    caption: post.caption?.text || '',
                                    timestamp: timestamp,
                                    isReal: true
                                });
                            });
                            
                        } catch (e) {
                            console.error('‚ùå Erro ao parsear posts reais:', e);
                        }
                    } else {
                        console.warn('‚ö†Ô∏è Nenhum post real encontrado no localStorage');
                    }
                    
                    // 2. CALCULAR RELEV√ÇNCIA E ORDENAR
                    if (realPosts.length > 0) {
                        // Identificar m√∫tuos para c√°lculo de relev√¢ncia
                        const mutualUsernames = new Set();
                        if (!isPrivate && followers.length > 0 && following.length > 0) {
                            const followersUsernames = new Set(followers.map(f => f.username?.toLowerCase()));
                            following.forEach(f => {
                                if (followersUsernames.has(f.username?.toLowerCase())) {
                                    mutualUsernames.add(f.username?.toLowerCase());
                                }
                            });
                        }
                        
                        // Calcular relev√¢ncia de cada post
                        realPosts.forEach(post => {
                            const isMutual = mutualUsernames.has(post.username?.toLowerCase());
                            post.relevanceScore = calculatePostRelevance(post, isMutual);
                        });
                    }
                        
                    // 3. ORDENAR POR TIMESTAMP (mais recente primeiro) e depois por relev√¢ncia
                    realPosts.sort((a, b) => {
                        // Primeiro por timestamp (mais recente primeiro)
                        const timeDiff = (b.timestamp || 0) - (a.timestamp || 0);
                        if (Math.abs(timeDiff) > 86400) { // Se diferen√ßa > 1 dia, priorizar timestamp
                            return timeDiff;
                        }
                        // Se posts s√£o do mesmo dia, ordenar por relev√¢ncia
                        return (b.relevanceScore || 0) - (a.relevanceScore || 0);
                        });
                    
                    // 4. PEGAR AT√â 6 POSTS MAIS RECENTES (com relev√¢ncia como crit√©rio secund√°rio)
                    const postsReais = realPosts.slice(0, 6);
                    
                    // 5. CRIAR POSTS FALLBACK se necess√°rio (para completar at√© 6 posts)
                    let needFallback = 6 - postsReais.length;
                    
                    // NUNCA criar s√≥ 1 fallback - se precisar de 1, criar 2
                    if (needFallback === 1) {
                        needFallback = 2;
                    }
                    
                    
                    // Criar availableUsers para fallback
                    const availableUsers = [];
                    
                    // Usar followers (que j√° foi populado com chaining_results para perfil privado)
                    // Se n√£o tiver followers suficiente, usar following como fallback
                    const sourceForFallback = followers.length > 0 ? followers : following;
                    // Se ainda n√£o tiver, usar chainingResults diretamente
                    const allSources = [...sourceForFallback, ...(chainingResults || [])];
                    
                    for (let i = 0; i < allSources.length; i++) {
                        const profile = allSources[i];
                        if (profile && profile.username) {
                            // N√£o usar perfis que j√° t√™m post real
                            const alreadyHasPost = postsReais.some(p => p.username === profile.username);
                            const alreadyAdded = availableUsers.some(u => u.username === profile.username);
                            if (!alreadyHasPost && !alreadyAdded) {
                                availableUsers.push({
                                    username: profile.username,
                                    profilePic: profile.profile_pic_url || profile.profile_pic_url_hd || '../imagens/default-avatar.png',
                                    fullName: profile.full_name || '',
                                    isPrivate: profile.is_private === true || profile.is_private === 'true' || profile.is_private === 1 || false
                                });
                            }
                        }
                    }
                    
                    
                    // Embaralhar availableUsers
                    const shuffledUsers = [...availableUsers].sort(() => Math.random() - 0.5);
                    
                    // 5. CRIAR POSTS FALLBACK (se necess√°rio)
                    const fallbackPosts = [];
                    
                    if (needFallback > 0 && shuffledUsers.length > 0) {
                        /*
                         * L√ìGICA DE INTERCALA√á√ÉO DE POSTS:
                         * ================================
                         * Posts reais + fallback s√£o intercalados por data para parecer natural.
                         * 
                         * Exemplo:
                         * - Posts reais: dia 1, dia 10, dia 20
                         * - Fallback calculado: dia 5 (entre 1-10), dia 15 (entre 10-20)
                         * 
                         * Resultado final ordenado por timestamp (mais recente primeiro):
                         * dia 20 (real) ‚Üí dia 15 (fallback) ‚Üí dia 10 (real) ‚Üí dia 5 (fallback) ‚Üí dia 1 (real)
                         * 
                         * Post da Choquei SEMPRE fica na 3¬™ posi√ß√£o, independente da data.
                         */
                        let fallbackDates = [];
                        
                        if (postsReais.length >= 2) {
                            // Ordenar posts reais por timestamp (mais recente primeiro)
                            const sortedRealPosts = [...postsReais].sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                            
                            // Calcular datas intermedi√°rias entre cada par de posts reais
                            for (let i = 0; i < sortedRealPosts.length - 1 && fallbackDates.length < needFallback; i++) {
                                const newerPost = sortedRealPosts[i].timestamp || 0;
                                const olderPost = sortedRealPosts[i + 1].timestamp || 0;
                                // Data intermedi√°ria = m√©dia entre os dois posts
                                const midDate = (newerPost + olderPost) / 2;
                                fallbackDates.push(midDate);
                            }
                            
                            // Se ainda precisa de mais datas, criar antes do post mais antigo
                            while (fallbackDates.length < needFallback) {
                                const oldestPost = sortedRealPosts[sortedRealPosts.length - 1].timestamp || (Date.now() / 1000);
                                const daysBeforeOldest = (fallbackDates.length + 1) * 3 * 86400; // 3, 6, 9 dias antes
                                fallbackDates.push(oldestPost - daysBeforeOldest);
                            }
                        } else if (postsReais.length === 1) {
                            // Um post real: criar fallback antes e depois
                            const realTimestamp = postsReais[0].timestamp || (Date.now() / 1000);
                            for (let i = 0; i < needFallback; i++) {
                                const offset = (i % 2 === 0 ? 1 : -1) * ((Math.floor(i / 2) + 1) * 3 * 86400);
                                fallbackDates.push(realTimestamp + offset);
                            }
                        } else {
                            // Sem posts reais: distribuir nos √∫ltimos 30 dias
                            const nowTimestamp = Date.now() / 1000;
                            for (let i = 0; i < needFallback; i++) {
                                const daysAgo = (i + 1) * 4 * 86400; // 4, 8, 12, 16 dias atr√°s
                                fallbackDates.push(nowTimestamp - daysAgo);
                            }
                        }
                        
                        // Criar posts fallback com as datas calculadas
                        for (let i = 0; i < needFallback && i < shuffledUsers.length; i++) {
                            const user = shuffledUsers[i];
                            fallbackPosts.push({
                                username: maskUsername(user.username),
                                profilePic: user.profilePic,
                                fullName: user.fullName,
                                imageUrl: '',
                                likes: Math.floor(Math.random() * 180) + 20,
                                comments: 0,
                                caption: '',
                                timestamp: fallbackDates[i] || (Date.now() / 1000),
                                isReal: false,
                                isFallback: true,
                                hideComments: true,
                                hideCaption: true,
                                aspectRatio: Math.random() > 0.5 ? '1 / 1' : '3 / 2'
                            });
                        }
                    }
                    
                    // 6. ADICIONAR POST DA CHOQUEI
                    // Se tiver posts reais: mostra imagem real | Se n√£o tiver: conte√∫do restrito (igual outros fallback)
                    const hasRealPosts = postsReais.length > 0;
                    const choqueiPost = {
                        username: 'choqu**',
                        profilePic: '../imagens/choquei.jpg',
                        imageUrl: hasRealPosts ? '../imagens/post-choquei.jpg' : '', // Vazio = conte√∫do restrito
                        comments: hasRealPosts ? 391 : 0,
                        caption: hasRealPosts ? 'casa cmg???' : '',
                        timestamp: Date.now() / 1000 - (2 * 86400),
                        isReal: false,
                        isChoquei: true,
                        isFallback: !hasRealPosts, // Marcar como fallback se n√£o tiver posts reais
                        verified: true,
                        aspectRatio: '3 / 2',
                        hideComments: !hasRealPosts,
                        hideCaption: !hasRealPosts,
                        reposts: hasRealPosts ? 296 : 0,
                        shares: hasRealPosts ? 1045 : 0,
                        locationType: 'none'
                    };
                    
                    // 7. COMBINAR POSTS REAIS + FALLBACK + CHOQUEI e ORDENAR POR TIMESTAMP (mais recente primeiro)
                    let allPosts = [...postsReais, ...fallbackPosts, choqueiPost];
                    allPosts.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                    
                    // Mover Choquei para 3¬™ posi√ß√£o se n√£o estiver l√°
                    const choqueiIndex = allPosts.findIndex(p => p.isChoquei);
                    if (choqueiIndex !== -1 && choqueiIndex !== 2 && allPosts.length > 2) {
                        const choquei = allPosts.splice(choqueiIndex, 1)[0];
                        allPosts.splice(2, 0, choquei);
                    }
                    
                    
                    // 8. CONVERTER PARA FORMATO ESPERADO PELO C√ìDIGO DE RENDERIZA√á√ÉO
                    // Criar mapa de perfis para buscar profilePic e fullName
                    const profilesMap = new Map();
                    const allProfiles = [...following, ...followers, ...chainingResults];
                    allProfiles.forEach(profile => {
                        if (profile.username) {
                            profilesMap.set(profile.username.toLowerCase(), {
                                profilePic: profile.profile_pic_url || profile.profile_pic_url_hd || '',
                                fullName: profile.full_name || '',
                                isPrivate: profile.is_private === true || profile.is_private === 'true' || profile.is_private === 1
                            });
                        }
                    });
                    
                    postsData = allPosts.map(post => {
                        // Buscar dados do perfil se for post real
                        let profilePic = post.profilePic || '';
                        let fullName = post.fullName || '';
                        let isPrivate = post.isPrivate || false;
                        
                        if (post.isReal) {
                            // Usar originalUsername para buscar foto (username est√° mascarado)
                            const lookupUsername = (post.originalUsername || post.username || '').toLowerCase();
                            const profileData = profilesMap.get(lookupUsername);
                            if (profileData) {
                                profilePic = profileData.profilePic;
                                fullName = profileData.fullName;
                                isPrivate = profileData.isPrivate;
                            }
                        }
                        
                        return {
                            username: post.isReal ? post.username : maskUsername(post.username),
                            profilePic: profilePic,
                            fullName: fullName,
                            isPrivate: isPrivate,
                            imageUrl: post.imageUrl,
                            likes: post.likes,
                            comments: post.comments || 0,
                            reposts: post.reposts || 0,
                            shares: post.shares || 0,
                            liked: Math.random() > 0.5,
                            saved: Math.random() > 0.7,
                            caption: post.caption || '',
                            date: formatPostDate(post.timestamp),
                            timestamp: post.timestamp,
                            aspectRatio: post.aspectRatio || '1 / 1',
                            verified: post.verified || false,
                            isReal: post.isReal || false,
                            isFallback: post.isFallback || false,
                            isChoquei: post.isChoquei || false,
                            hideComments: post.hideComments || false,
                            hideCaption: post.hideCaption || false,
                            locationType: post.locationType || 'none'
                        };
                    });
                    
                    // Criar hash dos dados usados para posts (chaining_results se privado, followers se p√∫blico)
                    const sourceData = (isPrivate || followers.length < 5) ? chainingResults : followers;
                    const postsDataHash = JSON.stringify(sourceData.slice(0, 20).map(u => ({ username: u.username, profile_pic_url: u.profile_pic_url || u.profile_pic_url_hd })));
                    
                    // Salvar ordem permanentemente
                    localStorage.setItem(POSTS_ORDER_KEY, JSON.stringify(postsData));
                    localStorage.setItem(POSTS_HASH_KEY, postsDataHash);
                    // Atualizar cookie quando salvar dados
                    setCookie('localStorage_active', '1', 365);
                }

                // Fun√ß√£o para formatar n√∫meros grandes
                function formatNumber(num) {
                    if (num >= 1000 && num < 10000) {
                        // Para n√∫meros entre 1000-9999, usar ponto como separador de milhar (ex: 8.491, 1.045)
                        const str = num.toString();
                        return str.slice(0, -3) + '.' + str.slice(-3);
                    } else if (num >= 10000 && num < 100000) {
                        // Para n√∫meros entre 10000-99999, usar ponto como separador de milhar (ex: 44.323)
                        const str = num.toString();
                        return str.slice(0, -3) + '.' + str.slice(-3);
                    } else if (num >= 1000) {
                        // Para n√∫meros >= 1000, usar formato com "mil" e uma casa decimal (ex: 13,1 mil)
                        const k = (num / 1000).toFixed(1);
                        return k.replace('.', ',') + ' mil';
                    }
                    return num.toString();
                }
                
                // Carregar todas as localiza√ß√µes primeiro
                let locations = [];
                const cityData = await detectCityByIP();
                if (!cityData) {
                    // Se n√£o conseguir pegar dados da API, todas as localiza√ß√µes ser√£o vazias
                    locations = postsData.map(() => '');
                } else {
                    // Primeiro, buscar cidades vizinhas de forma sequencial para garantir que sejam diferentes
                    const neighborCityPosts = [];
                    const usedNeighborCities = [];
                    
                    postsData.forEach((post, index) => {
                        if (post.locationType === 'neighbor_city') {
                            neighborCityPosts.push(index);
                        }
                    });
                    
                    // Buscar cidades vizinhas sequencialmente
                    for (const postIndex of neighborCityPosts) {
                        const neighbor = await getNeighborCity(cityData.lat, cityData.lon, usedNeighborCities);
                        if (neighbor) {
                            usedNeighborCities.push(neighbor);
                        }
                    }
                    
                    // Agora buscar todas as localiza√ß√µes
                    const locationPromises = postsData.map(async (post, index) => {
                        const locationType = post.locationType || 'none';
                        if (locationType === 'none') return ''; // Sem localiza√ß√£o, retorna vazio
                        
                        if (locationType === 'ip_city') {
                            return cityData.cidade || '';
                        }
                        
                        if (locationType === 'neighbor_city') {
                            // Pegar a cidade correspondente do array usadoNeighborCities
                            const neighborIndex = neighborCityPosts.indexOf(index);
                            return usedNeighborCities[neighborIndex] || '';
                        }
                        
                        if (locationType === 'famous_place') {
                            const place = await getFamousPlace(cityData.lat, cityData.lon, cityData);
                            return place || cityData.cidade || '';
                        }
                        
                        // Para 'hidden', retorna vazio (n√£o "Local Oculto")
                        return '';
                    });
                    
                    locations = await Promise.all(locationPromises);
                }
                
                // Manter a ordem original dos posts, apenas as fotos s√£o aleat√≥rias
                postsContainer.innerHTML = postsData.map((post, index) => {
                    // Usar data formatada que j√° vem no post.date
                    const relativeTime = post.date || 'Agora';
                    
                    // Calcular hor√°rio baseado no timestamp (se dispon√≠vel)
                    let time = '00:00';
                    if (post.timestamp) {
                        const postDate = new Date(post.timestamp * 1000);
                        const hours = postDate.getHours().toString().padStart(2, '0');
                        const minutes = postDate.getMinutes().toString().padStart(2, '0');
                        time = `${hours}:${minutes}`;
                    }
                    
                    const formattedDate = post.date || '';
                    
                    // Se for post REAL, usar imageUrl da API; se FALLBACK, n√£o mostrar imagem
                    let postImageUrl = '';
                    if (post.isReal && post.imageUrl) {
                        // Post real: usar imagem do post da API
                        postImageUrl = getProxyUrl(post.imageUrl);
                    } else if (post.isChoquei && post.imageUrl) {
                        // Post da Choquei: usar imagem espec√≠fica
                        postImageUrl = post.imageUrl;
                    }
                    // Posts fallback: postImageUrl fica vazio (apenas conte√∫do restrito)
                    
                    // Foto de perfil do usu√°rio (sempre usar profilePic para o avatar)
                    const postProfilePic = post.profilePic ? (post.profilePic.startsWith('../') || post.profilePic.startsWith('./') ? post.profilePic : getProxyUrl(post.profilePic)) : '';
                    
                    // Obter localiza√ß√£o do array carregado (vazio se n√£o houver)
                    const locationText = locations[index] || '';
                    
                    // Formatar n√∫meros (n√£o mostrar se for 0)
                    const formattedLikes = post.likes > 0 ? formatNumber(post.likes) : '';
                    const formattedComments = post.comments > 0 ? formatNumber(post.comments) : '';
                    const formattedReposts = post.reposts > 0 ? formatNumber(post.reposts) : '';
                    const formattedShares = post.shares > 0 ? formatNumber(post.shares) : '';
                    
                    // Username com verified borrado se necess√°rio
                    const displayUsername = post.username;
                    const showVerified = post.verified;
                    
                    return `
                        <div class="post-container" style="background: rgb(11, 16, 20); margin-bottom: 16px;">
                            <div style="padding: 12px 16px; display: flex; align-items: center; justify-content: space-between;">
                                <button style="display: flex; align-items: center; gap: 12px; background: none; border: none; cursor: pointer;">
                                    <div style="width: 32px; height: 32px; border-radius: 50%; overflow: hidden; background: rgb(31, 41, 55); position: relative;">
                                        ${post.locked ? `
                                            <img alt="${post.username}" src="${postProfilePic}" style="width: 100%; height: 100%; object-fit: cover; filter: blur(4px);">
                                            <div style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.4);">
                                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 12px; height: 12px; color: white;">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                                                </svg>
                                            </div>
                                        ` : `
                                            <img alt="${post.username}" src="${postProfilePic}" style="width: 100%; height: 100%; object-fit: cover;">
                                        `}
                                    </div>
                                    <div style="text-align: left;">
                                        <div style="display: flex; align-items: center; gap: 4px;">
                                            <p style="font-size: 14px; font-weight: 600; color: white; margin: 0;">${displayUsername}</p>
                                            ${showVerified ? `<img src="../imagens/verificado-ig.png" alt="Verificado" style="width: 12px; height: 12px; flex-shrink: 0; object-fit: contain;">` : ''}
                                        </div>
                                        ${locationText ? `<p style="font-size: 12px; color: rgb(156, 163, 175); margin: 0;">${locationText}</p>` : ''}
                                    </div>
                                </button>
                                <button class="blocked-action" style="background: none; border: none; cursor: pointer;">
                                    <svg fill="currentColor" viewBox="0 0 24 24" style="width: 20px; height: 20px; color: white;">
                                        <circle cx="12" cy="5" r="1.5"></circle>
                                        <circle cx="12" cy="12" r="1.5"></circle>
                                        <circle cx="12" cy="19" r="1.5"></circle>
                                    </svg>
                                </button>
                            </div>
                            <div class="post-image-container" style="width: 100%; aspect-ratio: ${post.aspectRatio}; background: rgb(18, 24, 34); display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 0; position: relative; overflow: hidden;">
                                ${postImageUrl ? `
                                    <img src="${postImageUrl}" alt="Post de ${post.username}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                                    <div style="display: none; width: 100%; height: 100%; background: rgb(18, 24, 34); flex-direction: column; align-items: center; justify-content: center;">
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 48px; height: 48px; color: rgb(107, 114, 128); margin-bottom: 12px;">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                                        </svg>
                                        <p style="color: rgb(156, 163, 175); font-weight: 500; margin: 0;">Conte√∫do restrito</p>
                                    </div>
                                ` : `
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 48px; height: 48px; color: rgb(107, 114, 128); margin-bottom: 12px;">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                                    </svg>
                                    <p style="color: rgb(156, 163, 175); font-weight: 500; margin: 0;">Conte√∫do restrito</p>
                                    <p style="color: rgb(107, 114, 128); font-size: 14px; margin-top: 4px;">${formattedDate} - ${time}</p>
                                `}
                            </div>
                            <div style="padding: 12px 16px;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                    <div style="display: flex; align-items: center; gap: 16px;">
                                        <button class="like-button" data-post-index="${index}" data-liked="${post.liked}" style="display: flex; align-items: center; gap: 4px; background: none; border: none; cursor: pointer;">
                                            <img alt="Curtir" src="../home-feed/icones/${post.liked ? 'coracao-curtido' : 'coracao'}.svg" style="width: 26px; height: 26px;">
                                            ${formattedLikes ? `<span class="likes-count-display" style="font-size: 14px; font-weight: 600; color: white;">${formattedLikes}</span>` : ''}
                                        </button>
                                        <button class="blocked-action" style="display: flex; align-items: center; gap: 4px; background: none; border: none; cursor: pointer;">
                                            <img alt="Comentar" src="../home-feed/icones/comentario.svg" style="width: 24px; height: 24px;">
                                            ${post.hideComments || !formattedComments ? '' : `<span style="font-size: 14px; font-weight: 600; color: white;">${formattedComments}</span>`}
                                        </button>
                                        ${post.usernameOverride === 'choqu**' ? '' : `
                                        <button class="blocked-action" style="display: flex; align-items: center; gap: 4px; background: none; border: none; cursor: pointer;">
                                            <img alt="Repost" src="../home-feed/icones/repost.svg" style="width: 24px; height: 24px;">
                                            ${formattedReposts ? `<span style="font-size: 14px; font-weight: 600; color: white;">${formattedReposts}</span>` : ''}
                                        </button>
                                        `}
                                        <button class="blocked-action" style="display: flex; align-items: center; gap: 4px; background: none; border: none; cursor: pointer;">
                                            <img alt="Enviar" src="../home-feed/icones/enviar.svg" style="width: 24px; height: 24px;">
                                            ${formattedShares ? `<span style="font-size: 14px; font-weight: 600; color: white;">${formattedShares}</span>` : ''}
                                        </button>
                                    </div>
                                    <button class="save-button" data-post-index="${index}" data-saved="${post.saved}" style="background: none; border: none; cursor: pointer;">
                                        <img alt="Salvar" src="../home-feed/icones/${post.saved ? 'salvar-salvado' : 'salvar'}.svg" style="width: 24px; height: 24px;">
                                    </button>
                                </div>
                                <div style="display: flex; flex-direction: column; gap: 8px;">
                                    ${post.hideCaption ? '' : `<div style="display: flex; align-items: flex-start; gap: 8px;">
                                        <span style="font-size: 14px; font-weight: 600; color: white;">${post.username}</span>
                                        <span style="font-size: 14px; color: rgb(209, 213, 219); filter: blur(4px); user-select: none;">${post.caption}</span>
                                    </div>
                                    <p style="font-size: 12.32px; color: rgb(156, 163, 175); margin: 0; margin-top: -8px;">${relativeTime}</p>`}
                                    ${post.hideCaption ? `<p style="font-size: 12.32px; color: rgb(156, 163, 175); margin: 0; margin-top: -8px;">${relativeTime}</p>` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Salvar HTML dos posts no sessionStorage
                sessionStorage.setItem('feed_posts_html_' + username, postsContainer.innerHTML);
                
                // Marcar que o feed foi renderizado e salvar timestamp
                sessionStorage.setItem(FEED_HTML_KEY, 'true');
                sessionStorage.setItem(FEED_TIMESTAMP_KEY, Date.now().toString());
                sessionStorage.setItem('feed_cache_version_' + username, 'v38');
                
                // ===== INFINITE SCROLL: Mostrar 3 posts iniciais, +3 ao scroll com loading =====
                const allPosts = postsContainer.querySelectorAll('.post-container');
                let visiblePosts = 3;
                let allPostsLoaded = false;
                
                // Esconder posts al√©m dos 3 primeiros
                allPosts.forEach((post, index) => {
                    if (index >= visiblePosts) {
                        post.style.display = 'none';
                    }
                });
                
                // Fun√ß√£o para criar skeleton loading
                function createLoadingSkeleton() {
                    const skeleton = document.createElement('div');
                    skeleton.className = 'post-loading-skeleton';
                    skeleton.innerHTML = `
                        <div class="skeleton-header">
                            <div class="skeleton-avatar"></div>
                            <div class="skeleton-username"></div>
                        </div>
                        <div class="skeleton-image"></div>
                        <div class="skeleton-actions">
                            <div class="skeleton-icon"></div>
                            <div class="skeleton-icon"></div>
                            <div class="skeleton-icon"></div>
                        </div>
                        <div class="skeleton-likes"></div>
                    `;
                    return skeleton;
                }
                
                // Fun√ß√£o para carregar mais posts com loading
                function loadMorePosts() {
                    if (visiblePosts >= allPosts.length) {
                        // Todos os posts carregados - mostrar banner
                        allPostsLoaded = true;
                        const banner = document.getElementById('all-posts-seen-banner');
                        if (banner) {
                            banner.classList.add('show');
                            const urlParams = new URLSearchParams(window.location.search);
                            const currentUsername = urlParams.get('username') || localStorage.getItem('username');
                            if (currentUsername) {
                                setCookie(`all_posts_seen_banner_shown_${currentUsername}`, 'true', 365);
                            }
                            // Scroll suave para o topo
                            setTimeout(() => {
                                window.scrollTo({ top: 0, behavior: 'smooth' });
                            }, 500);
                        }
                        return;
                    }
                    
                    // Adicionar skeleton loading
                    const skeleton = createLoadingSkeleton();
                    postsContainer.appendChild(skeleton);
                    
                    // Ap√≥s 800ms, remover skeleton e mostrar posts reais
                    setTimeout(() => {
                        skeleton.remove();
                        
                        const previousVisible = visiblePosts;
                        visiblePosts = Math.min(visiblePosts + 3, allPosts.length);
                        
                        // Mostrar novos posts
                        for (let i = previousVisible; i < visiblePosts; i++) {
                            if (allPosts[i]) {
                                allPosts[i].style.display = 'block';
                            }
                        }
                        
                        // Se carregou todos, mostrar banner
                        if (visiblePosts >= allPosts.length) {
                            allPostsLoaded = true;
                            const banner = document.getElementById('all-posts-seen-banner');
                            if (banner) {
                                banner.classList.add('show');
                                const urlParams = new URLSearchParams(window.location.search);
                                const currentUsername = urlParams.get('username') || localStorage.getItem('username');
                                if (currentUsername) {
                                    setCookie(`all_posts_seen_banner_shown_${currentUsername}`, 'true', 365);
                                }
                                // Scroll suave para o topo
                                setTimeout(() => {
                                    window.scrollTo({ top: 0, behavior: 'smooth' });
                                }, 500);
                            }
                        }
                    }, 800);
                }
                
                // Listener de scroll para infinite scroll
                let loadingMore = false;
                window.addEventListener('scroll', function() {
                    if (loadingMore || allPostsLoaded) return;
                    
                    const scrollPosition = window.scrollY + window.innerHeight;
                    const documentHeight = document.documentElement.scrollHeight;
                    
                    // Carregar mais quando estiver a 300px do final
                    if (scrollPosition >= documentHeight - 300) {
                        loadingMore = true;
                        loadMorePosts();
                        setTimeout(() => { loadingMore = false; }, 1000);
                    }
                }, { passive: true });
                
                // Configurar event listeners para op√ß√µes bloqueadas ap√≥s renderizar posts
                setTimeout(setupBlockedActions, 100);
            }
        }

        // Comportamento do header ao fazer scroll (igual Instagram)
        let lastScrollTop = 0;
        let scrollTimeout = null;
        const header = document.getElementById('main-header');
        
        function handleScroll() {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            
            if (scrollTop > lastScrollTop && scrollTop > 50) {
                // Scroll para baixo - esconder header
                if (header && !header.classList.contains('hidden')) {
                    header.classList.add('hidden');
                }
            } else if (scrollTop < lastScrollTop) {
                // Scroll para cima - mostrar header
                if (header && header.classList.contains('hidden')) {
                    header.classList.remove('hidden');
                }
            }
            
            lastScrollTop = scrollTop <= 0 ? 0 : scrollTop;
        }
        
        // Throttle do scroll para melhor performance
        window.addEventListener('scroll', function() {
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            scrollTimeout = setTimeout(handleScroll, 10);
        }, { passive: true });

        // Mostrar notifica√ß√£o Instagram iOS ap√≥s 3 segundos e deixar fixa
        function showIOSNotification() {
            // Garantir que o DOM est√° pronto antes de verificar os elementos
            if (document.readyState === 'loading') {
                setTimeout(showIOSNotification, 1000);
                return;
            }
            
            const notification = document.getElementById('ios-notification');
            const profilePicContainer = document.getElementById('notification-profile-pic');
            const messageEl = document.getElementById('notification-message');
            
            if (!notification || !profilePicContainer || !messageEl) {
                setTimeout(showIOSNotification, 2000);
                return;
            }
            
            // Buscar username atual para criar chave √∫nica por usu√°rio
            const urlParams = new URLSearchParams(window.location.search);
            const currentUsername = urlParams.get('username') || localStorage.getItem('username');
            
            if (!currentUsername) {
                return;
            }
            
            // Verificar se a notifica√ß√£o j√° foi mostrada para este usu√°rio espec√≠fico
            // Usar cookie ao inv√©s de localStorage para permitir reset quando necess√°rio
            const NOTIFICATION_SHOWN_KEY = `ios_notification_shown_${currentUsername}`;
            const notificationShown = getCookie(NOTIFICATION_SHOWN_KEY);
            
            if (notificationShown === 'true') {
                return;
            }
            
            if (notification && profilePicContainer && messageEl) {
                // Buscar dados para encontrar a mensagem "preciso falar contigo parada s√©ria"
                const username = urlParams.get('username') || localStorage.getItem('username');
                const userId = localStorage.getItem('userId') || localStorage.getItem('userPk') || localStorage.getItem('user_id') || localStorage.getItem('pk');
                
                // Buscar following
                const followingKey = userId ? `following_${userId}` : `following_${username}`;
                const followingRaw = localStorage.getItem(followingKey);
                let following = [];
                if (followingRaw) {
                    try {
                        following = JSON.parse(followingRaw);
                    } catch (e) {
                        console.error('Erro ao parsear following:', e);
                    }
                }
                
                // Se n√£o encontrou following, tentar outras chaves
                if (following.length === 0) {
                    const altKeys = ['following', `following_${username}`, 'following_users'];
                    for (const key of altKeys) {
                        const altRaw = localStorage.getItem(key);
                        if (altRaw) {
                            try {
                                following = JSON.parse(altRaw);
                                break;
                            } catch (e) {
                                console.error('Erro ao parsear following da chave', key, ':', e);
                            }
                        }
                    }
                }
                
                // Buscar followers tamb√©m para criar allUsers
                let followers = [];
                const followersKey = userId ? `followers_${userId}` : `followers_${username}`;
                const followersRaw = localStorage.getItem(followersKey);
                
                if (followersRaw) {
                    try {
                        followers = JSON.parse(followersRaw);
                    } catch (e) {
                        console.error('Erro ao parsear followers:', e);
                    }
                }
                
                // Criar allUsers combinando following e followers (igual em loadFeedData)
                const allUsers = [];
                const usernamesSeen = new Set();
                
                following.forEach(user => {
                    if (user && user.username && user.profile_pic_url && !usernamesSeen.has(user.username)) {
                        allUsers.push({
                            username: user.username,
                            full_name: user.full_name || '',
                            profile_pic_url: user.profile_pic_url
                        });
                        usernamesSeen.add(user.username);
                    }
                });
                
                followers.forEach(user => {
                    if (user && user.username && user.profile_pic_url && !usernamesSeen.has(user.username)) {
                        allUsers.push({
                            username: user.username,
                            full_name: user.full_name || '',
                            profile_pic_url: user.profile_pic_url
                        });
                        usernamesSeen.add(user.username);
                    }
                });
                
                // Usar o primeiro perfil (chat1 do direct) para a notifica√ß√£o
                // Prioridade: followers[0] (primeiro seguidor) ou following[0]
                let displayName = 'Fulano';
                const firstProfile = followers[0] || following[0] || allUsers[0];
                if (firstProfile) {
                    const fullName = firstProfile.full_name || '';
                    const firstName = fullName.split(' ')[0];
                    displayName = firstName || firstProfile.username || 'Fulano';
                }
                
                // Usar logo da notifica√ß√£o
                const img = document.createElement('img');
                img.src = '../imagens/Logo-notificcai.svg.png';
                img.alt = 'Instagram';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                profilePicContainer.innerHTML = '';
                profilePicContainer.appendChild(img);
                
                // Atualizar mensagem
                messageEl.textContent = `${displayName} enviou uma mensagem: "Preciso falar contigo uma parada s√©ria".`;
                
                // Marcar que a notifica√ß√£o foi mostrada (cookie)
                if (currentUsername) {
                    setCookie(`ios_notification_shown_${currentUsername}`, 'true', 365);
                }
                
                // Mostrar notifica√ß√£o
                notification.classList.add('show');
                
                // Aumentar contador de mensagens n√£o lidas de 2 para 3
                const unreadCountEl = document.getElementById('unread-messages-count');
                if (unreadCountEl) {
                    unreadCountEl.textContent = '3';
                }
                
                // Fazer notifica√ß√£o desaparecer ap√≥s 4 segundos
                setTimeout(() => hideNotification(), 4000);
                
                // Clicar na notifica√ß√£o
                notification.onclick = function() {
                    hideNotification();
                    window.location.href = '#';
                };
            } else {
                console.error('‚ùå Elementos da notifica√ß√£o n√£o encontrados no DOM');
            }
        }
        
        // Fun√ß√£o para esconder a notifica√ß√£o
        function hideNotification() {
            const notification = document.getElementById('ios-notification');
            if (notification && notification.classList.contains('show')) {
                notification.classList.add('hiding');
                setTimeout(() => {
                    notification.classList.remove('show');
                    notification.classList.remove('hiding');
                }, 300);
            }
        }

        // Fun√ß√£o para verificar se chegou ao final dos posts (agora gerenciado pelo infinite scroll)
        function checkEndOfPosts() {
            // L√≥gica movida para o infinite scroll integrado
            return;
        }
        
        // Fun√ß√£o para verificar se o banner j√° foi mostrado e exibir automaticamente
        function checkBannerOnLoad() {
            // L√≥gica agora gerenciada pelo infinite scroll
            // Esta fun√ß√£o √© mantida para compatibilidade mas n√£o faz mais nada
                return;
        }
        
        // Executar quando o DOM estiver pronto (mais r√°pido que window.load)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                // Carregar dados imediatamente
                loadFeedData();
                
                // Verificar banner ap√≥s loadFeedData terminar (com delay para garantir que o DOM foi atualizado)
                setTimeout(() => {
                    checkBannerOnLoad();
                }, 500);
                
                // Adicionar listener de scroll para detectar fim dos posts
                let scrollTimeout;
                window.addEventListener('scroll', function() {
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(checkEndOfPosts, 100);
                });
                // Configurar event listeners ap√≥s um pequeno delay
                setTimeout(setupBlockedActions, 100);
                // Mostrar notifica√ß√£o ap√≥s 10 segundos (apenas 1 vez)
                setTimeout(showIOSNotification, 10000);
            });
        } else {
            // DOM j√° est√° pronto
            loadFeedData();
            
            // Verificar banner ap√≥s loadFeedData terminar
            setTimeout(() => {
                checkBannerOnLoad();
            }, 500);
            
            // Adicionar listener de scroll para detectar fim dos posts
            let scrollTimeout;
            window.addEventListener('scroll', function() {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(checkEndOfPosts, 100);
            });
            
            setTimeout(setupBlockedActions, 100);
            setTimeout(showIOSNotification, 10000);
        }

        // Banner de pr√©via gr√°tis com timer de 5 minutos
        (function() {
            const PREVIEW_DURATION = 5 * 60 * 1000; // 5 minutos em milissegundos
            const STORAGE_KEY = 'previewStartTime';
            
            function formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            function initPreviewBanner() {
                // Verificar se j√° existe tempo salvo
                let startTime = localStorage.getItem(STORAGE_KEY);
                
                if (!startTime) {
                    // Primeira vez - salvar tempo atual
                    startTime = Date.now();
                    localStorage.setItem(STORAGE_KEY, startTime.toString());
                } else {
                    startTime = parseInt(startTime);
                }
                
                const elapsed = Date.now() - startTime;
                const remaining = PREVIEW_DURATION - elapsed;
                
                if (remaining <= 0) {
                    // Tempo esgotado - esconder banner
                    const banner = document.getElementById('preview-banner');
                    if (banner) {
                        banner.classList.add('hidden');
                        setTimeout(() => {
                            banner.remove();
                        }, 400);
                    }
                    localStorage.removeItem(STORAGE_KEY);
                    return;
                }
                
                // Atualizar timer inicial
                const timerText = document.getElementById('timer-text');
                if (timerText) {
                    timerText.textContent = formatTime(remaining);
                }
                
                // Atualizar timer a cada segundo
                const timerInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const remaining = PREVIEW_DURATION - elapsed;
                    
                    if (remaining <= 0) {
                        clearInterval(timerInterval);
                        const banner = document.getElementById('preview-banner');
                        if (banner) {
                            banner.classList.add('hidden');
                            setTimeout(() => {
                                banner.remove();
                            }, 400);
                        }
                        localStorage.removeItem(STORAGE_KEY);
                    } else {
                        const timerText = document.getElementById('timer-text');
                        if (timerText) {
                            timerText.textContent = formatTime(remaining);
                        }
                    }
                }, 1000);
            }
            
            // Inicializar quando o DOM estiver pronto
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initPreviewBanner);
            } else {
                initPreviewBanner();
            }
        })();
    </script>
</body>
</html>
