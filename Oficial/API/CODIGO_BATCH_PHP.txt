// ============================================
// CÓDIGO PARA ADICIONAR NO api-instagram.php
// ============================================

// 1. ADICIONAR APÓS A LINHA QUE DEFINE $apiType (linha ~46):
// Verificar se é requisição batch de posts
$isBatchPosts = isset($_GET['batch_posts']) && $_GET['batch_posts'] === 'true';
$batchUsernames = isset($_GET['usernames']) ? explode(',', $_GET['usernames']) : [];


// 2. ADICIONAR DENTRO DO if ($apiType === 'plagio'), LOGO NO INÍCIO (antes de buscar dados do usuário):
// Se for batch de posts, processar separadamente
if ($isBatchPosts && !empty($batchUsernames)) {
    try {
        // Limitar a 25 usuários
        $usernames = array_slice($batchUsernames, 0, 25);
        error_log("Batch posts request: " . count($usernames) . " usuários");
        
        // Buscar posts de cada usuário em paralelo
        $multiHandle = curl_multi_init();
        if (defined('CURLMOPT_PIPELINING') && defined('CURLPIPE_MULTIPLEX')) {
            curl_multi_setopt($multiHandle, CURLMOPT_PIPELINING, CURLPIPE_MULTIPLEX);
        }
        
        $curlHandles = [];
        $userIds = [];
        
        // Primeiro, buscar todos os user_ids em paralelo
        foreach ($usernames as $uname) {
            $uname = trim($uname);
            if (empty($uname)) continue;
            
            $url = "https://{$rapidApiHost}/v1/user/by/username?username=" . urlencode($uname);
            $ch = curl_init();
            curl_setopt_array($ch, [
                CURLOPT_URL => $url,
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_ENCODING => "gzip,deflate",
                CURLOPT_TIMEOUT => 10,
                CURLOPT_CONNECTTIMEOUT => 3,
                CURLOPT_HTTPHEADER => [
                    "x-access-key: {$plagioApiKey}",
                    "Accept: application/json",
                    "Accept-Encoding: gzip, deflate"
                ],
            ]);
            
            curl_multi_add_handle($multiHandle, $ch);
            $curlHandles[$uname] = ['handle' => $ch, 'type' => 'user'];
        }
        
        // Executar requisições de user_id
        $running = null;
        do {
            curl_multi_exec($multiHandle, $running);
            if ($running > 0) {
                usleep(1000);
            }
        } while ($running > 0);
        
        // Processar user_ids e buscar posts
        foreach ($curlHandles as $uname => $data) {
            $ch = $data['handle'];
            $response = curl_multi_getcontent($ch);
            $jsonData = json_decode($response, true);
            
            if ($jsonData && isset($jsonData['pk'])) {
                $userIds[$uname] = $jsonData['pk'];
            }
            
            curl_multi_remove_handle($multiHandle, $ch);
            curl_close($ch);
        }
        
        // Agora buscar posts de cada usuário em paralelo
        $curlHandles = [];
        foreach ($userIds as $uname => $userId) {
            $url = "https://{$rapidApiHost}/v1/user/medias/chunk?user_id=" . urlencode($userId);
            $ch = curl_init();
            curl_setopt_array($ch, [
                CURLOPT_URL => $url,
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_ENCODING => "gzip,deflate",
                CURLOPT_TIMEOUT => 10,
                CURLOPT_CONNECTTIMEOUT => 3,
                CURLOPT_HTTPHEADER => [
                    "x-access-key: {$plagioApiKey}",
                    "Accept: application/json",
                    "Accept-Encoding: gzip, deflate"
                ],
            ]);
            
            curl_multi_add_handle($multiHandle, $ch);
            $curlHandles[$uname] = ['handle' => $ch, 'type' => 'posts'];
        }
        
        // Executar requisições de posts
        $running = null;
        do {
            curl_multi_exec($multiHandle, $running);
            if ($running > 0) {
                usleep(1000);
            }
        } while ($running > 0);
        
        // Processar resultados
        $batchResults = [];
        foreach ($curlHandles as $uname => $data) {
            $ch = $data['handle'];
            $response = curl_multi_getcontent($ch);
            $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            $err = curl_error($ch);
            
            curl_multi_remove_handle($multiHandle, $ch);
            curl_close($ch);
            
            $jsonData = null;
            if ($response) {
                $jsonData = json_decode($response, true);
            }
            
            $post = null;
            if (!$err && $httpCode === 200 && $jsonData) {
                if (is_array($jsonData) && count($jsonData) > 0) {
                    $post = $jsonData[0]; // Primeiro post
                }
            }
            
            $batchResults[] = [
                'username' => $uname,
                'success' => $post !== null,
                'post' => $post,
                'error' => $post === null ? ($err ?: "HTTP {$httpCode}") : null
            ];
        }
        
        curl_multi_close($multiHandle);
        
        // Retornar resultados do batch
        echo json_encode([
            'batch_results' => $batchResults,
            'timestamp' => date('c')
        ], JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
        exit;
        
    } catch (Exception $e) {
        returnError('Erro ao processar batch de posts: ' . $e->getMessage());
    }
}


// 3. ADICIONAR APÓS BUSCAR $userData (linha ~308):
// Garantir que chaining_results seja preservado no resultado
if (isset($userData['chaining_results']) && is_array($userData['chaining_results'])) {
    error_log("Chaining results found: " . count($userData['chaining_results']) . " perfis");
}


// 4. ADICIONAR APÓS SALVAR EM $results['requests']['account_data'] (linha ~321):
// Garantir que chaining_results esteja acessível em result.data
if (isset($userData['chaining_results'])) {
    $results['requests']['account_data']['result']['data']['chaining_results'] = $userData['chaining_results'];
}
